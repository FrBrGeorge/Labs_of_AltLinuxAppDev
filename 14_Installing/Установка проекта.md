
---

Итоговый продукт любой разработки почти всегда представляет из себя целую систему связанных элементов, и не всегда удобно или возможно создавать на его основе пакет. Для распространения и использовании итогового продукта необходимо предусмотреть возможность «работы из коробки» исполняемых файлов и сопутствующих данных (в частности, доступ к документации). Несомненно, существует вариант распространения «чистых» исходников (через публичные репозитории, например), однако такой вариант требует от пользователя знаний и умений для донастройки (если не перенастройки) всех связей при ручной сборке и установке. Кроме этого могут возникнуть проблемы, связанные с недостатком библиотек или необходимых для сборки утилит.
## Варианты установки

Классическим вариантом установки является установка в соответствии со _стандартом иерархии файлов_ в файловой системе ([Filesystem_Hierarchy_Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard "WP")). Данные устанавливаются в системные директории`/usr/bin`, `/usr/lib64` и т. д. Установка в системные директории согласно FHS гарантирует работу устанавливаемого ПО, поскольку работа со всеми системными утилитами настроена под именно такое распределение файлов. Главный недостаток такой установки — необходимость прав суперпользователя, что допускает потенциальную возможность вторжения в систему. Менее опасным, но значимым недостатком такого способа установки является возможность конфликтов между устанавливаемым и системным ПО.

Для избежания конфликтов с системой появился метод установки в директории `/usr/local/…` Устанавливаемое туда ПО не конфликтует с базовыми системами, благодаря чему данный способ используется в проектах, подразумевающих множественные внутренние установки. Однако распределение файлов по такой иерархии не соответствует FHS, всё также требует прав суперпользователя и больше подвержено конфликтам между устанавливаемыми компонентами.

Гарантированно не вызывающий конфликтов способ установки — использование для каждого приложения уникального расположения в файловой системе. Такой способ возможен при установке в уникальную директорию `/opt/<AppName>/`. Для установки всё ещё требуются права суперпользователя, однако данный способ позволяет избежать пересечений между файлами разных приложений. Основной недостаток такого способа — необходимость явного указания в `$PATH` `/bin`-директории с устанавливаемым приложением для его запуска. Кроме этого при старте необходимо проводить дополнительную настройку связей (подтягивание всех зависимостей из нестандартных расположений), обычно это осуществляется через Shell-сценарии. Такая схема установки часто используется в сложных проектах, требующих притаскивания с собой разных библиотек и исполняемых файлов.

Для установки без прав суперпользователя располагать файлы можно в директориях пути `$HOME/.local/`. Такие установки являются локальными для конкретного пользователя, что может приводить к установке в одну систему нескольких копий одних и тех же приложений. Также установка в локальное пространство пользователя требует полной настройки зависимостей на другие локальные установки. Такой способ полезен для систем, ориентированных на разработчика, поскольку при разработке часто требуется отдельное (а иногда и не одно) независимое пространство установки. Для пользователей же работа с относительно изолированным пространством, требующим полной настройки связей, будет проблематичной.

Все схемы установки в специализированные директории файловой системы связаны с необходимостью динамической компоновки элементов, в частности, библиотек. При этом некоторые специфичные зависимости иногда проще описать статически. В случае, когда компоновка сочетает в себе и динамические, и статические связи, говорят о _гибридной системе_, установка которой основана на одной из вышеперечисленных схем. Основными проблемами такой сборки являются влияние статической компоновки на итоговые файлы (например, большие размеры исполняемых файлов) и вероятные проблемы версионирования между статическими и динамическими компонентами.

В случае, когда проблемы статической компоновки не так значительны, а работа устанавливаемого ПО должна быть гарантирована вне зависимости от места установки, используется _полная статическая компоновка_. Установка такого независимого ни от чего объекта не требует прав суперпользователя, конкретного места установки и т. д. Такой схемой можно собирать разные версии приложений.

## Управление установкой с помощью Autotools

Autotools непосредственно поддерживает возможность установки проектов в систему. По умолчанию за установочный путь принят `/usr/local`. Автоматически сгенерированные рецепты `make install` самостоятельно распределяют все компоненты по поддиректориям. Однако, как было сказано ранее, установка в `/usr/local`, во-первых, требует прав суперпользователя:

`@user`
```console
[user@VM syscall-master]$ autoreconf -fisv
<...>
[user@VM syscall-master]$ ./configure
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/usr/bin/mkdir -p '/usr/local/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/usr/local/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /usr/local/lib/libsyscall.so.0.0.0
/usr/bin/ginstall: cannot create regular file '/usr/local/lib/libsyscall.so.0.0.0': Permission denied
<...>
[user@VM syscall-master]$ tree /usr/local
/usr/local
├── bin
│   └── hypersh
├── doc
├── etc
├── games
├── include
├── lib
├── lib64
├── libexec
├── libx32
├── man
├── sbin
└── share
   ├── info
   └── man

15 directories, 1 file
```

Ещё раз напоминаем что при работе с правами суперпользователя нужно быть особенно бдительным!

```console
[root@VM ~]# cd /home/user/syscall-master/
[root@VM syscall-master]# make install
Making install in src
<...>
/usr/bin/mkdir -p '/usr/local/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/usr/local/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /usr/local/lib/libsyscall.so.0.0.0
libtool: install: (cd /usr/local/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /usr/local/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /usr/local/lib/libsyscall.la
/usr/bin/mkdir -p '/usr/local/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/usr/local/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /usr/local/bin/syscall
/usr/bin/mkdir -p '/usr/local/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/usr/local/share/man/man1'

[root@VM syscall-master]# tree /usr/local
/usr/local
├── bin
│   ├── hypersh
│   └── syscall
├── doc
├── etc
├── games
├── include
├── lib
│   ├── libsyscall.la
│   ├── libsyscall.so -> libsyscall.so.0.0.0
│   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   └── libsyscall.so.0.0.0
├── lib64
├── libexec
├── libx32
├── man
├── sbin
└── share
   ├── info
   └── man
       └── man1
           └── syscall.1

16 directories, 8 files
[root@VM syscall-master]#
```

Во-вторых, `/usr/local` не является единственным местом установки даже среди общепринятых. Более того, никто не ограничивает пользователя, разбирающегося в собственных действиях, производить установку в _любые_ места системы с оговоркой готовности пользователя самостоятельно настраивать дополнительные связи между компонентами при необходимости.

Для явного указания места установки проекта среди параметров `configure` существует ключ `--prefix=`, использующийся для указания места установки программы:

```console
[user@VM syscall-master]$ tree /tmp/
/tmp/
├── systemd-private-cf21b62e498d45469bbfe8c619515c2b-chronyd.service-1UNCOt  [error opening dir]
└── systemd-private-cf21b62e498d45469bbfe8c619515c2b-systemd-logind.service-pFMnpU  [error opening dir]

3 directories, 0 files
[user@VM syscall-master]$ ./configure --prefix=/tmp/qq
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/tmp/qq/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /tmp/qq/lib/libsyscall.so.0.0.0
libtool: install: (cd /tmp/qq/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /tmp/qq/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /tmp/qq/lib/libsyscall.la
libtool: finish: PATH="/home/user/.gemie/bin:/home/user/bin:/usr/bin:/bin:/usr/local/bin:/usr/games:/sbin" ldconfig -n /tmp/qq/lib
----------------------------------------------------------------------
Libraries have been installed in:
  /tmp/qq/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
  - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable
    during execution
  - add LIBDIR to the 'LD_RUN_PATH' environment variable
    during linking
  - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
  - have your system administrator add LIBDIR to '/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
/usr/bin/mkdir -p '/tmp/qq/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/tmp/qq/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /tmp/qq/bin/syscall
/usr/bin/mkdir -p '/tmp/qq/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/tmp/qq/share/man/man1'

[user@VM syscall-master]$ tree /tmp/qq
/tmp/qq
├── bin
│   └── syscall
├── lib
│   ├── libsyscall.la
│   ├── libsyscall.so -> libsyscall.so.0.0.0
│   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   └── libsyscall.so.0.0.0
└── share
   └── man
       └── man1
           └── syscall.1

6 directories, 6 files
[user@VM syscall-master]$
```

Место установки можно указать и на более раннем этапе — при оформлении `configure.ac`. Для этого в Autotools предусмотрены специальные макросы:
 + AC_PREFIX_DEFAULT(_prefix_) используется для явного указания пути установки по умолчанию взамен `/usr/local`;
 + AC_PREFIX_PROGRAM(_program_) позволяет указать не явный путь установки, а уже установленную программу для использования её места установки (если он описан в PATH). Например,  если программой выбрана `gcc`, и PATH содержит путь к `/usr/local/gnu/bin/gcc`, путём установки будет выбран `/usr/local/gnu`.

`@user`: `syscall-master/configure.ac`

```
<...>
AM_INIT_AUTOMAKE([foreign subdir-objects])
LT_INIT([disable-static])
AC_CONFIG_HEADERS([config.h])

AC_PREFIX_DEFAULT([/tmp/QKRQ])

DX_INIT_DOXYGEN([syscall], [Doxyfile], [doxygen-doc])
<...>
```

`@user`
```console
[user@VM syscall-master]$ autoreconf -fisv
<...>
[user@VM syscall-master]$ ./configure
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/usr/bin/mkdir -p '/tmp/QKRQ/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/tmp/QKRQ/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /tmp/QKRQ/lib/libsyscall.so.0.0.0
libtool: install: (cd /tmp/QKRQ/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /tmp/QKRQ/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /tmp/QKRQ/lib/libsyscall.la
libtool: finish: PATH="/home/user/.gemie/bin:/home/user/bin:/usr/bin:/bin:/usr/local/bin:/usr/games:/sbin" ldconfig -n /tmp/QKRQ/lib
----------------------------------------------------------------------
Libraries have been installed in:
  /tmp/QKRQ/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
  - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable
    during execution
  - add LIBDIR to the 'LD_RUN_PATH' environment variable
    during linking
  - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
  - have your system administrator add LIBDIR to '/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
/usr/bin/mkdir -p '/tmp/QKRQ/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/tmp/QKRQ/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /tmp/QKRQ/bin/syscall
/usr/bin/mkdir -p '/tmp/QKRQ/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/tmp/QKRQ/share/man/man1'

[user@VM syscall-master]$ tree tmp
tmp  [error opening dir]

0 directories, 0 files
[user@VM syscall-master]$ tree /tmp
/tmp
├── QKRQ
│   ├── bin
│   │   └── syscall
│   ├── lib
│   │   ├── libsyscall.la
│   │   ├── libsyscall.so -> libsyscall.so.0.0.0
│   │   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   │   └── libsyscall.so.0.0.0
│   └── share
│       └── man
│           └── man1
│               └── syscall.1
├── qq
│   ├── bin
│   │   └── syscall
│   ├── lib
│   │   ├── libsyscall.la
│   │   ├── libsyscall.so -> libsyscall.so.0.0.0
│   │   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   │   └── libsyscall.so.0.0.0
│   └── share
│       └── man
│           └── man1
│               └── syscall.1
├── systemd-private-cf21b62e498d45469bbfe8c619515c2b-chronyd.service-1UNCOt  [error opening dir]
└── systemd-private-cf21b62e498d45469bbfe8c619515c2b-systemd-logind.service-pFMnpU  [error opening dir]

15 directories, 12 files
[user@VM syscall-master]$
```