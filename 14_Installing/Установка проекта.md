
---

Итоговый продукт любой разработки почти всегда представляет из себя целую систему связанных элементов, и не всегда удобно или возможно создавать на его основе пакет. Для распространения и использовании итогового продукта необходимо предусмотреть возможность «работы из коробки» исполняемых файлов и сопутствующих данных (в частности, доступ к документации). Несомненно, существует вариант распространения «чистых» исходников (через публичные репозитории, например), однако такой вариант требует от пользователя знаний и умений для донастройки (если не перенастройки) всех связей при ручной сборке и установке. Кроме этого могут возникнуть проблемы, связанные с недостатком библиотек или необходимых для сборки утилит.
## Варианты установки

Прежде всего заметим, что наиболее надёжный вариант установки ПО в систему — это _пакет_ собранный в эту систему сообразно дисциплине сообщества. Использование Hasher и Gear делают результат RPM-пакета ещё более совместимым. Главный недостаток пакета, созданного по всем правилам — его необходимо _сопровождать_, то есть пересматривать работоспособность с каждым обновлением, затрагивающим его зависимости, пересобирать и исправлять в случае чего и т. д.

Какими неприятностями грозят «классические» варианты установки свежесобранного ПО по алгоритму «крибле! крабле! бумс!», то есть `./configure`, `make`, `make install`?

Установка в соответствии со _стандартом иерархии файлов_ в файловой системе ([Filesystem_Hierarchy_Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard)), которую мы использовали для сборки пакета, предполагает, что исполняемые файлы устанавливаются в системный каталог `/usr/bin`, библиотеки — в `/usr/lib64`, документация — в `/usr/share/doc` и т. д. Установка в системные директории согласно FHS гарантирует работу устанавливаемого ПО, поскольку работа со всеми системными утилитами настроена под именно такое распределение файлов. Сточки зрения разработчика у такого способа есть важный недостаток: размещение файлов в системных каталогах — это вмешательство в архитектуру ОС. Оно требует прав суперпользователя (даже если задача — просто потестировать очередной вариант сборки) и возлагает на программисте несвойственную ему ответственность за возможные файловые конфликты. Например, назвал программист свою программу «kitten» (котёнок) — что может пойти не так? А нет, в системе есть пакет с файлом `/usr/bin/kitten`, который заменился при установке.

Для избежания конфликтов с системой появился метод установки в директории `/usr/local/`. В традиционных Linux-дистрибутивах дерево каталогов в `/usr/local` не используется, но при этом каталоги `/usr/local/bin`, `/usr/local/lib64`, `/usr/local/share/man` и т. п. считаются стандартными местами для размещения файлов соответствующего типа. Устанавливаемое туда ПО не конфликтует с базовой системой, и именно этот способ включится по умолчанию в GNU Autotools, если отдельно не задать префикс установки. В FHS каталог `/usr/local` предназначен для т. н. «локальной установки» ПО, что частично совпадает с нашей целью, а частично  — нет. Для установки в `/usr/local` нужно иметь права суперпользователя, и продолжать следить за файловыми конфликтами устанавливаемых проектов _между собой_.

Гарантированно не вызывающий конфликтов способ установки — использование для каждого приложения уникального расположения в файловой системе. Такой способ возможен при установке в уникальную директорию `/opt/<AppName>/`. Для установки всё ещё требуются права суперпользователя, хотя это уже не обязательно, достаточно программисту выдать отдельный доступный подкаталог. Данный способ позволяет избежать файловых конфликтов. Основной недостаток такого способа — необходимость явного указания в `$PATH` `/bin`-директории с устанавливаемым приложением для его запуска. Что ещё важнее — подгружать динамические библиотеки из `/opt/<AppName>/lib` необходимо вручную — как минимум, дополнять путь загрузки с помощью `LD_LIBRARY_PATH`. Следовательно, исполняемый файл в такой установке должен сопровождаться shell-сценарием с соответствующей настойкой. Кроме того, согласно дисциплине ALT динамическое изменение параметров запуска приложений, включая `LD_LIBRARY_PATH`, `LD_PRELOAD`, не заработает для SUID/SGID программ из соображений безопасности. Такая схема установки часто используется в сложных проектах, в состав которых входит большое количество собственных библиотек (в том числе совпадающих по именам с системными, но модифицированных).

Время от времени разработчикам таких проектов приходит в голову, например, добавить `/opt/<AppName>/lib` в настройки [динамического компоновщика](https://man7.org/linux/man-pages/man8/ld.so.8.html) — практика показывает, что это опасная идея: не ровен час, сторонняя библиотека заместит системную…

Для установки без прав суперпользователя располагать файлы можно в подкаталогах `$HOME/.local/`. Такие установки являются локальными для конкретного пользователя, что может приводить к установке в одну систему нескольких копий одних и тех же приложений. Также установка в локальное пространство пользователя требует полной настройки зависимостей на другие локальные установки. Такой способ полезен для систем, ориентированных на разработчика, поскольку при разработке часто требуется отдельное (а иногда и не одно) независимое пространство установки, и для него требуется ещё более замысловатая настройка путей для загрузки динамических библиотек (в которых появляется непостоянный компонент `$HOME`), наподобие той, что реализована в GNU Libtool.

Все схемы установки в специализированные директории файловой системы связаны с необходимостью дополнительно настраивать динамическую компоновку с библиотеками, входящими в состав проекта. Проблему можно решить _полностью статической_ сборкой и компоновкой. В результате получается статический же исполняемый файл. Статические прогарммы не требуют для запуска никаких библиотек, даже GLibC — только поддержку ядром загружаемого формата ELF. Такие программы можно просто _скопировать_ в произвольную Linux-систему, и они там заработают. Например, тремя статически собранными пакетами — `ash-static`, `cpio-static` и `find-static` — пользуется hasher для того, чтобы развернуть изолированное сборочное окружение в [chroot](https://www.altlinux.org/Chroot)-каталоге, в котором изначально нет вообще ничего.
```console
[user@VM ~] rpmquery -f /usr/bin/cpio /usr/bin/cpio.static                        
cpio-2.15-alt1.x86_64
cpio-static-2.15-alt1.x86_64
[user@VM ~] file /usr/bin/cpio /usr/bin/cpio.static
/usr/bin/cpio:        ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d6dff4c6e0de24cd3c1334b152efcc5ebf89694a, for GNU/Linux 3.2.0, stripped
/usr/bin/cpio.static: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=e047490a73892cb9e762b0e409c73ea774c51ce9, for GNU/Linux 3.2.0, stripped
[user@VM ~] ldd /usr/bin/cpio /usr/bin/cpio.static
/usr/bin/cpio:
        linux-vdso.so.1 (0x00007f8786626000)
        libc.so.6 => /lib64/libc.so.6 (0x00007f87863de000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f8786628000)
/usr/bin/cpio.static:
        not a dynamic executable

```

Если программа разрабатывается для запуска в каком-то предсказуемом окружении, можно понадеяться на то, что в системе будут доступны стандартные библиотеки с определённым диапазоном версий. Это позволит не «таскать с собой» как минимум тот же `libc`, а при удачном стечении обстоятельств — отказаться от и базовых прикладных инструментариев, таких как Qt или GTK. При этом часть библиотек всё-таки собирается, для удобства — статически. Как правило это библиотеки собственной разработки и сторонние библиотеки, требующие модификации в составе проекта, и какая-нибудь сугубая редкость, надеяться на наличие которой в системе не имеет смысла. Напомним, что разговор идёт возможности установки «по месту», а не о _пакете_, в котором такая «редкость» просто ставится в зависимость. В последнее время стало популярно скачивать собирать из исходных текстов в составе проекта практически все сторонние компоненты. Такой подход называется «вендоринг», и он принят как основной в экосистемах языков Go и Rust.

Программа с завендоренными сторонними компонентами получается довольно большой, версии этих компонент отличаются от сборки к сборке, а получившийся исполняемый файл компонуется динамически, но зависит от минимума системных библиотек (часто — от одной только `libc`).


## Управление установкой с помощью Autotools

Autotools непосредственно поддерживает возможность установки проектов в систему. По умолчанию за установочный путь принят `/usr/local`. Автоматически сгенерированные рецепты `make install` самостоятельно распределяют все компоненты по поддиректориям. Однако, как было сказано ранее, установка в `/usr/local`, во-первых, требует прав суперпользователя:

`@user`
```console
[user@VM syscall-master]$ autoreconf -fisv
<...>
[user@VM syscall-master]$ ./configure
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/usr/bin/mkdir -p '/usr/local/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/usr/local/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /usr/local/lib/libsyscall.so.0.0.0
/usr/bin/ginstall: cannot create regular file '/usr/local/lib/libsyscall.so.0.0.0': Permission denied
<...>
[user@VM syscall-master]$ tree /usr/local
/usr/local
├── bin
│   └── hypersh
├── doc
├── etc
├── games
├── include
├── lib
├── lib64
├── libexec
├── libx32
├── man
├── sbin
└── share
   ├── info
   └── man

15 directories, 1 file
```

Ещё раз напоминаем что при работе с правами суперпользователя нужно быть особенно бдительным!

```console
[root@VM ~]# cd /home/user/syscall-master/
[root@VM syscall-master]# make install
Making install in src
<...>
/usr/bin/mkdir -p '/usr/local/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/usr/local/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /usr/local/lib/libsyscall.so.0.0.0
libtool: install: (cd /usr/local/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /usr/local/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /usr/local/lib/libsyscall.la
/usr/bin/mkdir -p '/usr/local/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/usr/local/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /usr/local/bin/syscall
/usr/bin/mkdir -p '/usr/local/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/usr/local/share/man/man1'

[root@VM syscall-master]# tree /usr/local
/usr/local
├── bin
│   ├── hypersh
│   └── syscall
├── doc
├── etc
├── games
├── include
├── lib
│   ├── libsyscall.la
│   ├── libsyscall.so -> libsyscall.so.0.0.0
│   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   └── libsyscall.so.0.0.0
├── lib64
├── libexec
├── libx32
├── man
├── sbin
└── share
   ├── info
   └── man
       └── man1
           └── syscall.1

16 directories, 8 files
[root@VM syscall-master]#
```

Во-вторых, `/usr/local` не является единственным местом установки даже среди общепринятых. Более того, никто не ограничивает пользователя, разбирающегося в собственных действиях, производить установку в _любые_ места системы с оговоркой готовности пользователя самостоятельно настраивать загрузку динамических библиотек.

Для явного указания места установки проекта среди параметров `configure` существует ключ `--prefix=`, использующийся для указания места установки программы:

```console
[user@VM syscall-master]$ tree /tmp/
/tmp/
├── systemd-private-cf21b62e498d45469bbfe8c619515c2b-chronyd.service-1UNCOt  [error opening dir]
└── systemd-private-cf21b62e498d45469bbfe8c619515c2b-systemd-logind.service-pFMnpU  [error opening dir]

3 directories, 0 files
[user@VM syscall-master]$ ./configure --prefix=/tmp/qq
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/tmp/qq/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /tmp/qq/lib/libsyscall.so.0.0.0
libtool: install: (cd /tmp/qq/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /tmp/qq/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /tmp/qq/lib/libsyscall.la
libtool: finish: PATH="/home/user/.gemie/bin:/home/user/bin:/usr/bin:/bin:/usr/local/bin:/usr/games:/sbin" ldconfig -n /tmp/qq/lib
----------------------------------------------------------------------
Libraries have been installed in:
  /tmp/qq/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
  - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable
    during execution
  - add LIBDIR to the 'LD_RUN_PATH' environment variable
    during linking
  - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
  - have your system administrator add LIBDIR to '/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
/usr/bin/mkdir -p '/tmp/qq/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/tmp/qq/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /tmp/qq/bin/syscall
/usr/bin/mkdir -p '/tmp/qq/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/tmp/qq/share/man/man1'

[user@VM syscall-master]$ tree /tmp/qq
/tmp/qq
├── bin
│   └── syscall
├── lib
│   ├── libsyscall.la
│   ├── libsyscall.so -> libsyscall.so.0.0.0
│   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   └── libsyscall.so.0.0.0
└── share
   └── man
       └── man1
           └── syscall.1

6 directories, 6 files
[user@VM syscall-master]$
```

Место установки можно указать и на более раннем этапе — при оформлении `configure.ac`. Для этого в Autotools предусмотрены специальные макросы:
 + AC_PREFIX_DEFAULT(_prefix_) используется для явного указания пути установки по умолчанию взамен `/usr/local`;
 + AC_PREFIX_PROGRAM(_program_) позволяет указать не явный путь установки, а уже установленную программу для использования её места установки (если он описан в PATH). Например,  если программой выбрана `gcc`, и PATH содержит путь к `/usr/local/gnu/bin/gcc`, путём установки будет выбран `/usr/local/gnu`.

`@user`: `syscall-master/configure.ac`

```
<...>
AM_INIT_AUTOMAKE([foreign subdir-objects])
LT_INIT([disable-static])
AC_CONFIG_HEADERS([config.h])

AC_PREFIX_DEFAULT([/tmp/QKRQ])

DX_INIT_DOXYGEN([syscall], [Doxyfile], [doxygen-doc])
<...>
```

`@user`
```console
[user@VM syscall-master]$ autoreconf -fisv
<...>
[user@VM syscall-master]$ ./configure
<...>
[user@VM syscall-master]$ make install
Making install in src
<...>
/usr/bin/mkdir -p '/tmp/QKRQ/lib'
/bin/sh ../libtool   --mode=install /usr/bin/ginstall -c   libsyscall.la '/tmp/QKRQ/lib'
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.so.0.0.0 /tmp/QKRQ/lib/libsyscall.so.0.0.0
libtool: install: (cd /tmp/QKRQ/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so.0 || { rm -f libsyscall.so.0 && ln -s libsyscall.so.0.0.0 libsyscall.so.0; }; })
libtool: install: (cd /tmp/QKRQ/lib && { ln -s -f libsyscall.so.0.0.0 libsyscall.so || { rm -f libsyscall.so && ln -s libsyscall.so.0.0.0 libsyscall.so; }; })
libtool: install: /usr/bin/ginstall -c .libs/libsyscall.lai /tmp/QKRQ/lib/libsyscall.la
libtool: finish: PATH="/home/user/.gemie/bin:/home/user/bin:/usr/bin:/bin:/usr/local/bin:/usr/games:/sbin" ldconfig -n /tmp/QKRQ/lib
----------------------------------------------------------------------
Libraries have been installed in:
  /tmp/QKRQ/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
  - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable
    during execution
  - add LIBDIR to the 'LD_RUN_PATH' environment variable
    during linking
  - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
  - have your system administrator add LIBDIR to '/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
/usr/bin/mkdir -p '/tmp/QKRQ/bin'
 /bin/sh ../libtool   --mode=install /usr/bin/ginstall -c syscall '/tmp/QKRQ/bin'
libtool: install: /usr/bin/ginstall -c .libs/syscall /tmp/QKRQ/bin/syscall
/usr/bin/mkdir -p '/tmp/QKRQ/share/man/man1'
/usr/bin/ginstall -c -m 644 syscall.1 '/tmp/QKRQ/share/man/man1'

[user@VM syscall-master]$ tree tmp
tmp  [error opening dir]

0 directories, 0 files
[user@VM syscall-master]$ tree /tmp
/tmp
├── QKRQ
│   ├── bin
│   │   └── syscall
│   ├── lib
│   │   ├── libsyscall.la
│   │   ├── libsyscall.so -> libsyscall.so.0.0.0
│   │   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   │   └── libsyscall.so.0.0.0
│   └── share
│       └── man
│           └── man1
│               └── syscall.1
├── qq
│   ├── bin
│   │   └── syscall
│   ├── lib
│   │   ├── libsyscall.la
│   │   ├── libsyscall.so -> libsyscall.so.0.0.0
│   │   ├── libsyscall.so.0 -> libsyscall.so.0.0.0
│   │   └── libsyscall.so.0.0.0
│   └── share
│       └── man
│           └── man1
│               └── syscall.1
├── systemd-private-cf21b62e498d45469bbfe8c619515c2b-chronyd.service-1UNCOt  [error opening dir]
└── systemd-private-cf21b62e498d45469bbfe8c619515c2b-systemd-logind.service-pFMnpU  [error opening dir]

15 directories, 12 files
[user@VM syscall-master]$
```
## Собственный репозиторий

**TODO** Я понял, что если начну писать это сам, завязну окончательно. 

`https://www.altlinux.org/ПутиКРепозиториям` (в конце)

Полказать, что оно работает (например, пересобрать пакет, и он dist-upgrade-ом обновится даже если версия та же — потому что timestamp более свежий)

А вотом посмотреть вот сюда:

`https://www.altlinux.org/Создание_собственного_репозитория`

вместо httpd2, конечно, запустить просто `python3 -m http.server -d где`

проверить
