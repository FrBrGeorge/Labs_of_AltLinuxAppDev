Данная лабораторная работа продолжает повествование второй части главы о [библиотеках и тестировании](https://github.com/UsamG1t/Methodics_of_LinuxAppDev/blob/master/Methodical_manual/10_LibTesting/10.%20%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.md).

---

**TODO** не использовать `моноширинный шрифт` для отметки терминов на английском (он отмечает неязыковые объекты в тексте).

## Сборка большого проекта

Изучив основной спектр инструментов по разработке, отладке и автоматизации сборки пакетов, уже можно заниматься разработкой проектов под Альт. Вследствие этого последующие главы будут описывать работу с одним проектом.

За основу взят проект [syscall](https://github.com/oliwer/syscall), позволяющий работать с системными вызовами из командной строки. В рамках адаптации проекта под формат Альт-пакета необходимо добавить автоматическую конфигурацию для автосборки (`autotools` для конфигурации и `libtool` для удобства работы не с монолитным исходным кодом, а с библиотекой из небольших понятных файлов). Также необходимо распределить файлы по каталогам в соответствии с **TODO** _неееее_, поищите [тут](https://www.gnu.org/prep/standards/standards.html) -[общепринятой иерархией](https://man7.org/linux/man-pages/man7/hier.7.html)--.

Итоговое дерево директорий и [пакет с исходным кодом](Attached_materials/syscall-1.0-alt1.src.rpm) преобразованного проекта представлены.

```
.
├── configure.ac
├── doc
│   ├── Makefile.am
│   └── syscall.pod
├── LICENSE
├── Makefile.am
└── src
   ├── basic.c
   ├── globals.c
   ├── lssyscalls
   ├── Makefile.am
   ├── syscall.c
   ├── syscall.h
   └── utility.c
.gear/
├── rules
└── syscall.spec
```

Для работы с данным проектом его необходимо развернуть в `gear`-репозиторий с помощью `gear-srpmimport` (как описано в главе о [работе со сценариями](../03_Text/%3C%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D1%81%D0%BE%20%D1%81%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D1%8F%D0%BC%D0%B8.md%3E#Gear%20by%20ALT%20Linux%20Team))

## Тестирование проекта

Тестирование является одним из важнейших этапов разработки. Оно позволяет разобрать семантику кода, проверить его работу, а также работу и состояние того информационного пространства,  которое этот код создаёт и с которым взаимодействует (глобальные переменные, макросы, переменные окружения).

Выделяют 4 вида тестирования:
 + **Модульное** — проверяет работу отдельных модулей написанного продукта
 + **Системное** — проверяет работу всей системы изолированно от внешних зависимостей
 + **Интеграционное** — проверяет работу в рамках среды, в которой она запускается, и на, вообще говоря, не нами задаваемых условиях среды
 + **Приёмочное тестирование** — проверяет внешнее воздействие на проект, внесение невстроенных тестов и проверка поведения системы вообще на её взаимодействие с программами

Объектом обсуждения этой главы является модульное тестирование по дисциплиине [xUnit](https://ru.wikipedia.org/wiki/xUnit), задающее собственный путь тестирования системы.

**TODO** подумать, не перевести ли термины на русский

В рамках Unit-тестов определён «test **runner**» — основная программа, запускающая тесты. Он отвечает за проверку подключаемости тестирующего кода , фильтрацию тестов, сбор информации по запускам и т.д. Все тесты («**test**») объединены в отдельные тестирующие блоки («test **case**»), проверяющие какое-то конкретное свойство проекта. Множества блоков, описывающих один раздел работы с проектом объединены в «test **suite**». Как правило, в один suite входят тесты, работающие в одинаковых или похожих условиях, а если условия существенно разные (например, бэкенд в виде файла и бекенд в базе данных) — в отдельные.

	Для более точного понимания можно запомнить, что suit показывает, «в каких условиях сломалось», case — «какая функциональность сломалась?", test — «что именно сломалась?»

Следующий важный блок любого тестирования — подготовка и ликвидация тестируемого окружения — test **fixture**, или _фикстуры_. Фикстуры могут создаваться для каждого из уровней тестирования и описывать все временно создаваемые данные и предварительно выполняемые действия для проверки работоспособности системы. 

Одним из критериев качества тестирования является «test **coverage**» — _покрытие_, описывающее полноту тестирования программы. Самый простой показатель — процент строк исходного текста проекта, которые были выполнены в ходе тестирования. Более сложные показатели включают в себя проверку различных «execution path» — путей выполнения кода: например, если в одно и то же место программы можно попасть, предварительно пройдя и клаузу `if` условного оператора, и клаузу `else`, нужно иметь _два набора_ тестов соответствующего места.

Одна из классических подсистем тестирования проектов на Си — [Check](https://libcheck.github.io/check/). Работа с ней также автоматизирована в Autotools, что позволяет встраивать её в проекты и проводить тестирование при сборке пакетов без дополнительных действий.

Добавим тестирование в проект. Для начала укажем зависимость на `check`, воспользовавшись тем, что соответствующие проверки пакет `check` добавляет в утилиту определения зависимостей [pkgconfig](https://en.wikipedia.org/wiki/pkg-config):

`@user`: `syscall-master/configure.ac`

```patch
@@ 11,6 11,9 @@ AC_CONFIG_HEADERS([config.h])
 # Checks for programs.
 AC_PROG_CC

+# Joint pkgconfig library/include check and variable definition.
+PKG_CHECK_MODULES([CHECK],[check])
+
 # Checks for libraries.

 # Checks for header files.
```

`Unit`-тесты пишутся в виде `TypeScript`-файлов, для генерации исполняемых файлов из них используется субутилита `checkmk`

`@user`: `syscall-master/tests/Makefile.am`

```make
TESTS = include upstream
check_PROGRAMS = include upstream

.ts.c:
       checkmk $< > $@

AM_CFLAGS = -I$(top_builddir)/src @CHECK_CFLAGS@
LDADD = $(top_builddir)/src/libsyscall.la @CHECK_LIBS@
```

В самих тестах используются специальные функции-макросы для проверки значений. Проверка включает в себя работу как с локальными переменными тестов, так и с глобальными значениями, как, например, указатели на функции библиотеки.

`@user`: `syscall-master/tests/include.ts`

```ts
#include <check.h>
#include "syscall.h"

#test include
       ck_assert_ptr_nonnull(parse_arg);
       ck_assert_ptr_nonnull(lookup);
```

`@user`: `syscall-master/tests/upstream.ts`

```ts
#include <check.h>
#include "syscall.h"

int res;
unsigned long ulres;

#suite utility
#tcase scomp
#test diff_syscalls
       Syscall sys1 = {"write", 0};
       Syscall sys2 = {"read", 0};
       res = scomp(&sys1, &sys2);
       ck_assert_int_gt(res, 0);

#test same_syscalls
       Syscall sys1 = {"open", 0};
       Syscall sys2 = {"open", 0};
       res = scomp(&sys1, &sys2);
       ck_assert_int_eq(res, 0);

#tcase lookup
#test found
       char name[] = "write";
       res = lookup(name);
       ck_assert_int_eq(res, 1);

#suite basic
#tcase parse_arg
#test arg_length
       char syscall_name[] = "write";
       char arg[] = "#hello";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 5);

#test arg_retval
       ret_values[12] = 42;

       char syscall_name[] = "write";
       char arg[] = "$12";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 42);

#test arg_number
       char syscall_name[] = "write";
       char arg[] = "100500";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 100500);
```

В `spec`-файле к зависимости на генератор документации нужно также добавить зависимости на сам `check` и на его C-библиотеку:

`@user`: `syscall-master/.gear/syscall.spec`

```spec
Name: syscall
Version: 1.1
Release: alt1

Summary: send system calls from your shell

License: GPLv3+
Group: Development/Other

Source0: %name-%version.tar.gz

# Automatically added by buildreq on Fri Aug 08 2025
# optimized out: glibc-kernheaders-generic glibc-kernheaders-x86 gnu-config libgpg-error perl perl-Encode perl-Pod-Escapes perl-Pod-Simple perl-parent perl-podlators sh5
BuildRequires: perl-Pod-Usage libcheck-devel check

%description
Execute a list of raw system calls. All the system calls listed in your system's
unistd.h are supported, with up to 5 arguments. A maximum of 20 calls can be
executed per invocation, each separated by a comma.

Arguments starting by a # symbol are used to give a string length.
For instance, #hello would be evaluated as 5.

Arguments starting by a $ followed by a number from 0 to 19 refer to a previous
system call return code. For instance, $0 refers to to the return code of the
first system call executed.
To display those values, use the echo built-in command.

The echo command can be used like any other system call
to easily display $ or # values, or any string or number.

%prep
%setup

%build
%autoreconf
%configure
%make_build

%install
%makeinstall_std

%check
make check

%files
%_bindir/%name
%_libdir/*
%_man1dir/*

%changelog
* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.1-alt1
- Add xUnit check

* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.0-alt1
- Initial Build
```

```
.
├── configure.ac
├── doc
│   ├── Makefile.am
│   └── syscall.pod
├── LICENSE
├── Makefile.am
├── src
│   ├── basic.c
│   ├── globals.c
│   ├── lssyscalls
│   ├── Makefile.am
│   ├── syscall.c
│   ├── syscall.h
│   └── utility.c
└── tests
   ├── include.ts
   ├── Makefile.am
   └── upstream.ts
.gear/
├── rules
└── syscall.spec
```

`@user`
```console
[user@VM syscall-master]$ gear-hsh --lazy
<...>
Executing(%check): /bin/sh -e /usr/src/tmp/rpm-tmp.70349
+ umask 022
+ /bin/mkdir -p /usr/src/RPM/BUILD
+ cd /usr/src/RPM/BUILD
+ cd syscall-1.1
+ make check
<...>
checkmk include.ts > include.c
<...>
PASS: include
PASS: upstream
============================================================================
Testsuite summary for syscall 1.0
============================================================================
# TOTAL: 2
# PASS:  2
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
<...>
Wrote: /usr/src/RPM/SRPMS/syscall-1.1-alt1.src.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/syscall-1.1-alt1.x86_64.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/syscall-debuginfo-1.1-alt1.x86_64.rpm (w2.lzdio)
11.68user 11.20system 0:23.99elapsed 95%CPU (0avgtext+0avgdata 24184maxresident)k
760inputs+19696outputs (0major+888811minor)pagefaults 0swaps
[user@VM syscall-master]$

[user@VM syscall-master]$ cp ~/hasher/repo/x86_64/RPMS.hasher/syscall-1.1-alt1.x86_64.rpm ~/hasher/chroot/.in/
[user@VM syscall-master]$ hsh-shell --rooter
```

`@rooter`
```console
[root@localhost .in]# rpm -i syscall-1.1-alt1.x86_64.rpm
<13>Aug  8 11:55:52 rpm: syscall-1.1-alt1 1754653927 installed
[root@localhost .in]# which syscall
/usr/bin/syscall
[root@localhost .in]# ls /usr/share/man/man1/syscall.1.xz
/usr/share/man/man1/syscall.1.xz

[root@localhost .in]# cd
[root@localhost ~]# syscall open my.file 0101 0755 , write '$0' hello '#hello' , close '$0'
[root@localhost ~]# cat my.file
hello[root@localhost ~]#
```

---

`@user`: `syscall-master/Makefile.am`

```make
SUBDIRS = src doc tests

checklog:       check
       cat tests/*.log

gcov:   check
       $(MAKE) $(MAKEFLAGS) -C src gcov
```

`@user`: `syscall-master/configure.ac`

```
#                                               -*- Autoconf -*-
# Process this file with autoconf to produce a configure script.


AC_INIT([syscall], [1.0], [UsamG1t])
AC_CONFIG_SRCDIR([src/syscall.c])
AM_INIT_AUTOMAKE([foreign subdir-objects])
LT_INIT([disable-static])
AC_CONFIG_HEADERS([config.h])

# Checks for programs.
AC_PROG_CC

# Joint pkgconfig library/include check and variable definition.
PKG_CHECK_MODULES([CHECK],[check])

# Variable definitins
AC_SUBST(CK_VERBOSITY, verbose)
AC_ARG_VAR(CK_VERBOSITY, [Default: "verbose", can be "silent", "minimal" or "normal")])

# Enabe/disable things
AC_ARG_ENABLE([gcov],
             [AS_HELP_STRING([--enable-gcov], [use Gcov to test the test suite])],
             [], [enable_gcov=no])

AM_CONDITIONAL([COND_GCOV],[test '!' "$enable_gcov" = no])# Checks for libraries.

# Checks for header files.
AC_CHECK_HEADERS([err.h])
AC_CHECK_HEADERS([errno.h])
AC_CHECK_HEADERS([limits.h])
AC_CHECK_HEADERS([stdio.h])
AC_CHECK_HEADERS([stdlib.h])
AC_CHECK_HEADERS([string.h])
AC_CHECK_HEADERS([unistd.h])

# Optional clues

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.
AC_FUNC_ERROR_AT_LINE

AC_CONFIG_FILES([Makefile src/Makefile doc/Makefile tests/Makefile])
AC_OUTPUT
```

`@user`: `syscall-master/src/Makefile.am`

```make
CFLAGS  = -Wall -O0 -g
if COND_GCOV
CFLAGS  += -fprofile-arcs -ftest-coverage
endif

lib_LTLIBRARIES=libsyscall.la
libsyscall_la_SOURCES=globals.c utility.c basic.c
BUILT_SOURCES = syscall.h systab.h

bin_PROGRAMS = syscall
syscall_SOURCES = syscall.c
syscall_LDADD = libsyscall.la

systab.h:
       sh lssyscalls | awk '{printf "{\"%s\", %d},\n", $$1, $$2}' > $@

gcov:
       gcov -o .libs libsyscall -t -k -b | egrep -v '[[:digit:]]:[ /][*]'
```

