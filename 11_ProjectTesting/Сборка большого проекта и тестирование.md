Данная лабораторная работа продолжает повествование второй части главы о [библиотеках и тестировании](https://github.com/UsamG1t/Methodics_of_LinuxAppDev/blob/master/Methodical_manual/10_LibTesting/10.%20%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.md).

---

## Сборка большого проекта

Изучив основной спектр инструментов по разработке, отладке и автоматизации сборки пакетов уже можно заниматься разработкой проектов под Альт. Вследствие этого последующие главы будут описывать работу с одним проектом.

За основу взят проект [syscall](https://github.com/oliwer/syscall), позволяющий работать с системными вызовами из командной строки. В рамках адаптации проекта под формат Альт-пакета необходимо добавить автоматическую конфигурацию для автосборки (`autotools` для конфигурации и `libtool` для удобства работы не с монолитным исходным кодом, а с библиотекой из небольших понятных файлов). Также необходимо распределить файлы по каталогам в соответствии с [общепринятой иерархией](https://man7.org/linux/man-pages/man7/hier.7.html).

Итоговое дерево директорий и [пакет с исходным кодом](Attached_materials/syscall-1.0-alt1.src.rpm) преобразованного проекта представлены.

```
.
├── configure.ac
├── doc
│   ├── Makefile.am
│   └── syscall.pod
├── LICENSE
├── Makefile.am
└── src
   ├── basic.c
   ├── globals.c
   ├── lssyscalls
   ├── Makefile.am
   ├── syscall.c
   ├── syscall.h
   └── utility.c
.gear/
├── rules
└── syscall.spec
```

Для работы с данным проектом его необходимо развернуть в `gear`-репозиторий с помощью `gear-srpmimport` (как описано в главе о [работе со сценариями](../03_Text/<Работа со сценариями.md>#Gear by ALT Linux Team))

## Тестирование проекта

Тестирование является одним из важнейших этапов разработки. Оно позволяет разобрать семантику кода, проверить его работу, а также работу и состояние того информационного пространства,  которое этот код создаёт и с которым взаимодействует (глобальные переменные, макросы, переменные окружения).

Выделяют 4 вида тестирования:
 + **Модульное** - проверяет работу отдельных модулей написанного продукта
 + **Системное** - проверяет работу всей системы изолированно от внешних зависимостей
 + **Интеграционное** - проверяет работу в рамках среды, в которой она запускается, и на, вообще говоря, не нами задаваемых условиях среды
 + **Приёмочное тестирование** - проверяет внешнее воздействие на проект, внесение невстроенных тестов и проверка поведения системы вообще на её взаимодействие с программами

Объектом обсуждения этой главы является модульное тестирование `xUnit`, задающее собственный путь тестирования системы.

В рамках `Unit`-тестов определён `test Runner` - основная программа, запускающая тесты. Он отвечает за проверку подключаемости тестирующего кода , фильтрацию тестов, сбор информации по запускам и т.д. Все тесты (`test`) объединены в отдельные тестирующие блоки (`case`), описывающие работу какой-то конкретной функции. Множества блоков, описывающих один раздел работы с проектом (например, _работа с файлами_) объединены в `test suite`.

	Для более точного понимания можно запомнить, что `suite` описывает "Какая функциональность сломалась?", `case` - "Какая функция сломалась?", `test` - "На каких данных сломалась?"

Следующий важный блок любого тестирования - подготовка и ликвидация тестируемого окружения - _фикстуры_. Они могут создаваться для каждого из уровней тестирования и описывать все необходимые зависимости и данные для проверки работоспособности системы. Также в рамках тестирования считается специальный параметр `coverage`, описывающий полноту тестирования программы. Это может быть проверка как процент количества отработанных строк, описывающий тесты, так и проверка путей исполняемых тестов.

Одна из классических утилит для создания тестирования это [***check***](https://libcheck.github.io/check/). Работа с ней также автоматизирована в `autotools`, что позволяет встраивать её в проекты и проводить тестирование при сборке пакетов без дополнительных действий.

`@user`: `syscall-master/configure.ac`

```patch
@@ 11,6 11,9 @@ AC_CONFIG_HEADERS([config.h])
 # Checks for programs.
 AC_PROG_CC

+# Joint pkgconfig library/include check and variable definition.
+PKG_CHECK_MODULES([CHECK],[check])
+
 # Checks for libraries.

 # Checks for header files.
```

`@user`: `syscall-master/tests/Makefile.am`

```make
TESTS = include upstream
check_PROGRAMS = include upstream

.ts.c:
       checkmk $< > $@

AM_CFLAGS = -I$(top_builddir)/src @CHECK_CFLAGS@
LDADD = $(top_builddir)/src/libsyscall.la @CHECK_LIBS@
```

`@user`: `syscall-master/tests/include.ts`

```ts
#include <check.h>
#include "syscall.h"

#test include
       ck_assert_ptr_nonnull(parse_arg);
       ck_assert_ptr_nonnull(lookup);
```

`@user`: `syscall-master/tests/upstream.ts`

```ts
#include <check.h>
#include "syscall.h"

int res;
unsigned long ulres;

#suite utility
#tcase scomp
#test diff_syscalls
       Syscall sys1 = {"write", 0};
       Syscall sys2 = {"read", 0};
       res = scomp(&sys1, &sys2);
       ck_assert_int_gt(res, 0);

#test same_syscalls
       Syscall sys1 = {"open", 0};
       Syscall sys2 = {"open", 0};
       res = scomp(&sys1, &sys2);
       ck_assert_int_eq(res, 0);

#tcase lookup
#test found
       char name[] = "write";
       res = lookup(name);
       ck_assert_int_eq(res, 1);

#suite basic
#tcase parse_arg
#test arg_length
       char syscall_name[] = "write";
       char arg[] = "#hello";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 5);

#test arg_retval
       ret_values[12] = 42;

       char syscall_name[] = "write";
       char arg[] = "$12";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 42);

#test arg_number
       char syscall_name[] = "write";
       char arg[] = "100500";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 100500);
```

