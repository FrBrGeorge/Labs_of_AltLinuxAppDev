Данная лабораторная работа продолжает повествование второй части главы о [библиотеках и тестировании](https://github.com/UsamG1t/Methodics_of_LinuxAppDev/blob/master/Methodical_manual/10_LibTesting/10.%20%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.md).

---

## Сборка большого проекта

Изучив основной спектр инструментов по разработке, отладке и автоматизации сборки пакетов, уже можно заниматься разработкой проектов под Альт. Вследствие этого последующие главы будут описывать работу с одним проектом.

За основу взят проект [syscall](https://github.com/oliwer/syscall), позволяющий работать с системными вызовами из командной строки. В рамках адаптации проекта под формат Альт-пакета необходимо добавить автоматическую конфигурацию для автосборки (autotools для конфигурации и libtool — после того, как выделим библиотеку из монолитного исходного текста). Также необходимо распределить файлы по каталогам в соответствии со [общепринятой практикой](https://www.sourceware.org/autobook/autobook/autobook_45.html#GNU-Autotools-in-Practice)

Итоговое дерево директорий и [пакет с исходными текстами](Attached_materials/syscall-1.0-alt1.src.rpm) преобразованного проекта:

```
.
├── configure.ac
├── doc
│   ├── Makefile.am
│   └── syscall.pod
├── LICENSE
├── Makefile.am
└── src
   ├── basic.c
   ├── globals.c
   ├── lssyscalls
   ├── Makefile.am
   ├── syscall.c
   ├── syscall.h
   └── utility.c
.gear/
├── rules
└── syscall.spec
```

Для работы с данным проектом его необходимо развернуть в gear-репозиторий с помощью `gear-srpmimport` (как описано в главе о [работе со сценариями](../03_Text/%3C%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D1%81%D0%BE%20%D1%81%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D1%8F%D0%BC%D0%B8.md%3E#Gear%20by%20ALT%20Linux%20Team))

## Тестирование проекта

Тестирование является одним из важнейших этапов разработки. Оно позволяет разобрать семантику кода, проверить его работу, а также работу и состояние того информационного пространства,  которое этот код создаёт и с которым взаимодействует (глобальные переменные, макросы, переменные окружения).

Выделяют 4 вида тестирования:
 + **Модульное** — проверяет работу отдельных модулей написанного продукта
 + **Системное** — проверяет работу всей системы изолированно от внешних зависимостей
 + **Интеграционное** — проверяет работу в рамках среды, в которой она запускается, и на, вообще говоря, не нами задаваемых условиях среды
 + **Приёмочное тестирование** — проверяет внешнее воздействие на проект, внесение невстроенных тестов и проверка поведения системы вообще на её взаимодействие с программами

Объектом обсуждения этой главы является модульное тестирование по дисциплиине [xUnit](https://ru.wikipedia.org/wiki/xUnit), задающее собственный путь тестирования системы.

В рамках Unit-тестов определён **раннер** (test **runner**) — основная программа, запускающая тесты. Он отвечает за проверку подключаемости тестирующего кода , фильтрацию тестов, сбор информации по запускам и т.д. Все **тесты** (**test**) объединены в отдельные **тестовые комплекты** (test **case**), проверяющие какое-то конкретное свойство проекта. Множества блоков, описывающих один раздел работы с проектом объединены в **тестовые случаи** (test **suite**). Как правило, в один тестовый случай входят тесты, работающие в одинаковых или похожих условиях, а если условия существенно разные (например, бэкенд в виде файла и бэкенд в базе данных) — в отдельные.

    Для более точного понимания можно запомнить, что случай показывает, «в каких условиях сломалось?», комплект — «какая функциональность сломалась?", а сам тест — «что именно сломалось?»

Следующий важный блок любого тестирования — подготовка и ликвидация тестируемого окружения — test **fixture**, или _фикстуры_. Фикстуры могут создаваться для каждого из уровней тестирования и описывать все временно создаваемые данные и предварительно выполняемые действия для проверки работоспособности системы.

Одним из критериев качества тестирования является test **coverage** — **покрытие**, описывающее полноту тестирования программы. Самый простой показатель — процент строк исходного текста проекта, которые были выполнены в ходе тестирования. Более сложные показатели включают в себя проверку различных **execution path** — путей выполнения кода: например, если в одно и то же место программы можно попасть, предварительно пройдя и клаузу `if` условного оператора, и клаузу `else`, нужно иметь _два набора_ тестов соответствующего места.

Одна из классических подсистем тестирования проектов на Си — [Check](https://libcheck.github.io/check/). Работа с ней также автоматизирована в autotools, что позволяет встраивать её в проекты и проводить тестирование при сборке пакетов без дополнительных действий.

Добавим тестирование в проект. Для начала укажем зависимость на check, воспользовавшись тем, что соответствующие проверки пакет `check` добавляет в утилиту определения зависимостей [pkgconfig](https://en.wikipedia.org/wiki/pkg-config):

`@user`: `syscall-master/configure.ac`

```patch
@@ 11,6 11,9 @@ AC_CONFIG_HEADERS([config.h])
 # Checks for programs.
 AC_PROG_CC

+# Joint pkgconfig library/include check and variable definition.
+PKG_CHECK_MODULES([CHECK],[check])
+
 # Checks for libraries.

 # Checks for header files.
```

Поскольку check — это просто библиотека, тесты — это обычные функции на Си. Каждая тестирующая программа состоит из нескольких частей:
* сами тесты;
* задание тестового комплекта, тестовых случаев, раннера и, возможно, фикстур;
* регистрация: какие случаи принадлежат каким комплектам, какие тесты принадлежат каким случаям;
* запуск раннера;
* освобождение ресурсов.

Рассмотрим минимальный пример с простейшим тестом — проверкой на наличие соответствующей функции.

```c
#include <stdio.h>
#include <assert.h>
#include <check.h>
#include "syscall.h"

START_TEST(parse_arg_incl) {
	assert(parse_arg != NULL);
}
END_TEST

int main(int argc, char *argv[]) {
	Suite *suite = suite_create("incl");
	TCase *testcase = tcase_create("incl");
	SRunner *runner = srunner_create(suite);
	int ret;

	suite_add_tcase(suite, testcase);
	tcase_add_test(testcase, parse_arg_incl);
	srunner_run_all(runner, CK_ENV);
	ret = srunner_ntests_failed(runner);
	srunner_free(runner);
	return ret != 0;
}
```

В примере видно, что:
* тесты описываются внутри специальных макросов `START_TEST`/`END_TEST` (превращаются в функции);
* создание объектов тестирования, их регистрация друг в друге, запуск раннера и анализ результатов — отдельные атомарные операции;
* раннер создаётся на базе хотя бы одного тестового комплекта (потом туда можно добавить ещё);
* по окончании тестирования программист обязан вызвать `srunner_free()`, освобождая память не только самого раннера, но и рекурсивно всех зарегистрированных в нём объектов.

Ручное составление тестовых файлов — довольно монотонная и долгая задача. Однако большая часть тестового файла вполне может быть сгенерирована, для этого в пакет `libcheck` входит утилита `checkmk`. Тестовые файлы пишутся всё так же на Си, но общая часть задаётся директивами, похожими на Си-препроцессор, а в `Makefile.am` добавляется вызов `checkmk`.

`@user`: `syscall-master/tests/Makefile.am`

```make
TESTS = include upstream
check_PROGRAMS = include upstream

.ts.c:
	checkmk $< > $@

AM_CFLAGS = -I$(top_builddir)/src @CHECK_CFLAGS@
LDADD = $(top_builddir)/src/libsyscall.la @CHECK_LIBS@
```

Традиционно исходники для `checkmk` имеют расширение `.ts` (от **t**est **s**uite), поэтому многие текстовые редакторы пытаются включить подсветку синтаксиса TypeScript — она, конечно, плохо подходит.

В самих тестах используются специальные функции-макросы для проверки значений. Проверка включает в себя работу как с локальными переменными тестов, так и с глобальными значениями, как, например, указатели на функции библиотеки.

Воспроизведём пример выше с использованием макросов, и также добавим проверку на наличие ещё одной функции:

`@user`: `syscall-master/tests/include.ts`

```ts
#include <check.h>
#include "syscall.h"

#test include
       ck_assert_ptr_nonnull(parse_arg);
       ck_assert_ptr_nonnull(lookup);
```

В более существенном примере проверим работоспособность некоторых функций:
 + Тестовые случаи описывают функциональность программы из разных файлов библиотеки;
 + Тестовые комплекты проверяют функциональность конкретной функции
 + Тесты описывают ситуации с конкретными параметрами:
   + Разные или одинаковые имена системных вызовов
   + Бинарный поиск системного вызова в таблице
   + Обработку аргумента системного вызова

В качестве параметров тестируемых функций могут выступать как локальные переменные отдельного теста, так и глобальные переменные.

`@user`: `syscall-master/tests/upstream.ts`

```ts
#include <check.h>
#include "syscall.h"

int res;
unsigned long ulres;

#suite utility
#tcase scomp
#test diff_syscalls
       Syscall sys1 = {"write", 0};
       Syscall sys2 = {"read", 0};
       res = scomp(&sys1, &sys2);
       ck_assert_int_gt(res, 0);

#test same_syscalls
       Syscall sys1 = {"open", 0};
       Syscall sys2 = {"open", 0};
       res = scomp(&sys1, &sys2);
       ck_assert_int_eq(res, 0);

#tcase lookup
#test found
       char name[] = "write";
       res = lookup(name);
       ck_assert_int_eq(res, 1);

char syscall_name[] = "write";

#suite basic
#tcase parse_arg
#test arg_length
       char arg[] = "#hello";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 5);

#test arg_retval
       ret_values[12] = 42;

       char arg[] = "$12";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 42);

#test arg_number
       char arg[] = "100500";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 100500);
```

Подробнее рассмотрим обновлённый spec-файл:

`@user`: `syscall-master/.gear/syscall.spec`

```spec
Name: syscall
Version: 1.1
Release: alt1

Summary: send system calls from your shell
URL: https://github.com/oliwer/syscall
License: ISC
Group: Other

Source0: %name-%version.tar.gz

# Automatically added by buildreq on Fri Aug 08 2025
# optimized out: glibc-kernheaders-generic glibc-kernheaders-x86 gnu-config libgpg-error perl perl-Encode perl-Pod-Escapes perl-Pod-Simple perl-parent perl-podlators sh5
BuildRequires: perl-Pod-Usage libcheck-devel check

%description
Execute a list of raw system calls. All the system calls listed in your system's
unistd.h are supported, with up to 5 arguments. A maximum of 20 calls can be
executed per invocation, each separated by a comma.

Arguments starting by a # symbol are used to give a string length.
For instance, #hello would be evaluated as 5.

Arguments starting by a $ followed by a number from 0 to 19 refer to a previous
system call return code. For instance, $0 refers to to the return code of the
first system call executed.
To display those values, use the echo built-in command.

The echo command can be used like any other system call
to easily display $ or # values, or any string or number.

%prep
%setup

%build
%autoreconf
%configure
%make_build

%install
%makeinstall_std

%check
make check

%files
%_bindir/%name
%_libdir/*
%_man1dir/*

%changelog
* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.1-alt1
- Add xUnit check

* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.0-alt1
- Initial Build
```

Поскольку исходный текст проекта расположен на отдельном сетевом ресурсе, в spec-файле должно быть добавлено указание на него, для этого используется директива `URL`. Также, поскольку в проекте уже указана лицензия (о том, какая именно лицензия, а также их разновидности и отличия, будет рассказано в будущей главе), в spec-файле указывается она (заметим, что смена лицензии _конкретно в этом случае_ была бы допустима, но явной необходимости для этого нет). Наконец, к зависимости на генератор документации нужно также добавить сборочные зависимости на пакет `check` и на его C-библиотеку.

Итоговый Gear-репозиторий выглядит так:

```
.
├── configure.ac
├── doc
│   ├── Makefile.am
│   └── syscall.pod
├── LICENSE
├── Makefile.am
├── src
│   ├── basic.c
│   ├── globals.c
│   ├── lssyscalls
│   ├── Makefile.am
│   ├── syscall.c
│   ├── syscall.h
│   └── utility.c
└── tests
   ├── include.ts
   ├── Makefile.am
   └── upstream.ts
.gear/
├── rules
└── syscall.spec
```

`@user`
```console
[user@VM syscall-master]$ gear-hsh --lazy
<...>
Executing(%check): /bin/sh -e /usr/src/tmp/rpm-tmp.70349
+ umask 022
+ /bin/mkdir -p /usr/src/RPM/BUILD
+ cd /usr/src/RPM/BUILD
+ cd syscall-1.1
+ make check
<...>
checkmk include.ts > include.c
<...>
PASS: include
PASS: upstream
============================================================================
Testsuite summary for syscall 1.0
============================================================================
# TOTAL: 2
# PASS:  2
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
<...>
Wrote: /usr/src/RPM/SRPMS/syscall-1.1-alt1.src.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/syscall-1.1-alt1.x86_64.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/syscall-debuginfo-1.1-alt1.x86_64.rpm (w2.lzdio)
11.68user 11.20system 0:23.99elapsed 95%CPU (0avgtext+0avgdata 24184maxresident)k
760inputs+19696outputs (0major+888811minor)pagefaults 0swaps
[user@VM syscall-master]$

[user@VM syscall-master]$ cp ~/hasher/repo/x86_64/RPMS.hasher/syscall-1.1-alt1.x86_64.rpm ~/hasher/chroot/.in/
[user@VM syscall-master]$ hsh-shell --rooter
```

`@rooter`
```console
[root@localhost .in]# rpm -i syscall-1.1-alt1.x86_64.rpm
<13>Aug  8 11:55:52 rpm: syscall-1.1-alt1 1754653927 installed
[root@localhost .in]# which syscall
/usr/bin/syscall
[root@localhost .in]# ls /usr/share/man/man1/syscall.1.xz
/usr/share/man/man1/syscall.1.xz

[root@localhost .in]# cd
[root@localhost ~]# syscall open my.file е101 0755 , write '$0' hello '#hello' , close '$0'
[root@localhost ~]# cat my.file
hello[root@localhost ~]#
```

### Тестовое покрытие

Теперь для версии 1.2 добавим измерения покрытия программы тестами. Для этого добавим в `Makefile.am` дополнительный рецепт для запуска утилиты [gcov](https://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html), которая обрабатывает результаты тестирования:

`@user`: `syscall-master/Makefile.am`

```make
SUBDIRS = src doc tests

checklog:       check
	cat tests/*.log

gcov:   check
	$(MAKE) -C src gcov
```

 + Для ручного показа статистики по тестированию добавлен рецепт `checklog`
 + Рецепт `make gcov` в основном `Makefile` требует предварительного запуска тестов (`check`), после чего вызывает `make gcov` в каталоге `src`:

Собирать статистику о выполнении _строк исходного текста_ можно только если программа особым образом скомпилирована: в её код добавлено постоянное обновление многочисленных счётчиков, проверка достижимости и т. п. Исполняемые файлы, скомпилированные для проверки покрытия, непригодны к _эксплуатации_: они работают гораздо медленнее, потребляют больше ресурсов и при запуске создают множество временных файлов с отчётами.

**TODO** Начиная с этого места опять чехарда с применением `gcov`: вместо `gcov -o .libs libsyscall`  надо вызывать `gcov` с именами *исходников* (и их там четыре, а не один)

**TODO** соответственно изменить `.src.rpm`

`@user`: `syscall-master/src/Makefile.am`

```make
CFLAGS  = -Wall -O0 -g
if COND_GCOV
CFLAGS  += -fprofile-arcs -ftest-coverage
endif

lib_LTLIBRARIES=libsyscall.la
libsyscall_la_SOURCES=globals.c utility.c basic.c
BUILT_SOURCES = syscall.h systab.h

bin_PROGRAMS = syscall
syscall_SOURCES = syscall.c
syscall_LDADD = libsyscall.la

systab.h:
	sh lssyscalls | awk '{printf "{\"%s\", %d},\n", $$1, $$2}' > $@

gcov:
	gcov -o .libs libsyscall -t -k -b | grep -v -E '[[:digit:]]:[ /][*]'
```

Утилита `gcov` принимает на вход исходный текст библиотеки с указанным именем (libsyscall) **☹** из рабочей директории (.libs) и собирает статистику по количеству отработанных в процессе тестирования строк кода и, дополнительно (благодаря ключу `-b`), вариантов обработки условий (в условных операторах / switch-case конструкции и т.д.). Из данной статистики нас будут интересовать выводы по количеству выполнения строк кода.

**TODO** запустить `make COND_GCOV=1 gcov`, показать, где и какие отчёты наплодились

Для удобства можно добавить задание `COND_GCOV` параметром `configure`.

`@user`: `syscall-master/configure.ac`

```
<...>

# Variable definitins
AC_SUBST(CK_VERBOSITY, verbose)
AC_ARG_VAR(CK_VERBOSITY, [Default: "verbose", can be "silent", "minimal" or "normal")])

# Enabe/disable things
AC_ARG_ENABLE([gcov],
             [AS_HELP_STRING([--enable-gcov], [use gcov to collect test suite coverage])],
             [], [enable_gcov=no])

AM_CONDITIONAL([COND_GCOV],[test '!' "$enable_gcov" = no])

# Checks for libraries.

# Checks for header files.
<...>
```

Для обработки ключа в spec-файле воспользуемся уже известными макросами `%def_enable` для пробрасывания ключа в `./configure`. В директиву `%check` добавим явный запуск gcov, чтобы отслеживать статистику прямо при сборке пакета.

**TODO** Так делать не надо — _пакет_ не должен быть собран с coverage. Наверное, надо сделать так: создать отдельный каталог, перейти в него, оттуда вызвать `../configure --enable-gcov && %make`. Соответственно, вместо `subst_enable` использовать `%if_enabled` (или как его там) вокруг этого места и вокруг `make gcov` в `%check`.

`@user`: `syscall-master/.gear/syscall.spec`

```spec
%def_enable gcov

Name: syscall
Version: 1.2
Release: alt1

<...>

%build
%autoreconf
%configure %{subst_enable gcov}
%make_build

%install
%makeinstall_std

%check
make check
make gcov

%files
%_bindir/%name
%_libdir/*
%_man1dir/*

%changelog
* Mon Aug 11 2025 UsamG1t <usamg1t@altlinux.org> 1.2-alt1
- Add gcov

* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.1-alt1
- Add xUnit check

* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.0-alt1
- Initial Build
```

`@user`
```console
[user@VM syscall-master]$ gear-hsh --lazy
<...>
Executing(%check): /bin/sh -e /usr/src/tmp/rpm-tmp.73347
+ umask 022
+ /bin/mkdir -p /usr/src/RPM/BUILD
+ cd /usr/src/RPM/BUILD
+ cd syscall-1.2
+ make check
<...>
checkmk include.ts > include.c
<...>
PASS: include
PASS: upstream
============================================================================
Testsuite summary for syscall 1.0
============================================================================
# TOTAL: 2
# PASS:  2
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
<...>
make -C src gcov
make[1]: Entering directory '/usr/src/RPM/BUILD/syscall-1.2/src'
gcov -o .libs basic -t -k -b | grep -v -E '[[:digit:]]:[ /][*]'
       -:    0:Colorization: profile count: zero coverage (exceptional) zero coverage (unexceptional) unexecuted block
       -:    0:Source:basic.c
       -:    0:Graph:.libs/basic.gcno
       -:    0:Data:.libs/basic.gcda
       -:    0:Runs:14
       -:    1:#include "syscall.h"
       -:    2:
function parse_arg called 6 returned 100% blocks executed 81%
       6:    3:unsigned long parse_arg(const char *syscall_name, char *arg)
       -:    4:{
       -:    5:  unsigned long num;
       6:    6:  char *endp = NULL;
       -:    7:
       -:    8:  /* #hello - length of a string */
       6:    9:  if (arg[0] == '#') {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
       2:   10:    return (unsigned long)strlen(arg + 1);
       -:   11:  }
       -:   12:
       -:   13:  /* $0 - return value of a previous syscall */
       4:   14:  if (arg[0] == '$') {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       2:   15:    num = strtoul(arg + 1, &endp, 10);
call    0 returned 100%
       2:   16:    if (num < CMD_MAX - 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       2:   17:      return (unsigned long)ret_values[num];
       -:   18:    }
       -:   19:  }
       -:   20:
       -:   21:  /* Try to parse it as a number */
       2:   22:  endp = NULL;
       2:   23:  num = strtoul(arg, &endp, 0);
call    0 returned 100%
       2:   24:  if (errno == ERANGE) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       0:   25:    errx(1, "%s: argument '%s' is out of range",
call    0 never executed
       -:   26:      syscall_name, arg);
       -:   27:  }
       2:   28:  if (endp && *endp == '\0') {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       -:   29:    /* strtoul succeeded */
       2:   30:    return num;
       -:   31:  }
       -:   32:
       -:   33:  /* assume it is a string */
       -:   34:  /* unescape any \n at the end of the string */
       0:   35:  unescape_nl(arg);
call    0 never executed
       0:   36:  return (unsigned long)arg;
       -:   37:}
       -:   38:
<...>
```
