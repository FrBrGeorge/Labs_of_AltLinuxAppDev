Данная лабораторная работа продолжает повествование второй части главы о [библиотеках и тестировании](https://github.com/UsamG1t/Methodics_of_LinuxAppDev/blob/master/Methodical_manual/10_LibTesting/10.%20%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.md).

---

## Сборка большого проекта

Изучив основной спектр инструментов по разработке, отладке и автоматизации сборки пакетов, уже можно заниматься разработкой проектов под Альт. Вследствие этого последующие главы будут описывать работу с одним проектом.

За основу взят проект [syscall](https://github.com/oliwer/syscall), позволяющий работать с системными вызовами из командной строки. В рамках адаптации проекта под формат Альт-пакета необходимо добавить автоматическую конфигурацию для автосборки (autotools для конфигурации и libtool для удобства работы не с монолитным исходным кодом, а с библиотекой из небольших понятных файлов). Также необходимо распределить файлы по каталогам в соответствии со [общепринятой практикой](https://www.sourceware.org/autobook/autobook/autobook_45.html#GNU-Autotools-in-Practice)

Итоговое дерево директорий и [пакет с исходным кодом](Attached_materials/syscall-1.0-alt1.src.rpm) преобразованного проекта представлены.

```
.
├── configure.ac
├── doc
│   ├── Makefile.am
│   └── syscall.pod
├── LICENSE
├── Makefile.am
└── src
   ├── basic.c
   ├── globals.c
   ├── lssyscalls
   ├── Makefile.am
   ├── syscall.c
   ├── syscall.h
   └── utility.c
.gear/
├── rules
└── syscall.spec
```

Для работы с данным проектом его необходимо развернуть в gear-репозиторий с помощью gear-srpmimport (как описано в главе о [работе со сценариями](../03_Text/%3C%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D1%81%D0%BE%20%D1%81%D1%86%D0%B5%D0%BD%D0%B0%D1%80%D0%B8%D1%8F%D0%BC%D0%B8.md%3E#Gear%20by%20ALT%20Linux%20Team))

## Тестирование проекта

Тестирование является одним из важнейших этапов разработки. Оно позволяет разобрать семантику кода, проверить его работу, а также работу и состояние того информационного пространства,  которое этот код создаёт и с которым взаимодействует (глобальные переменные, макросы, переменные окружения).

Выделяют 4 вида тестирования:
 + **Модульное** — проверяет работу отдельных модулей написанного продукта
 + **Системное** — проверяет работу всей системы изолированно от внешних зависимостей
 + **Интеграционное** — проверяет работу в рамках среды, в которой она запускается, и на, вообще говоря, не нами задаваемых условиях среды
 + **Приёмочное тестирование** — проверяет внешнее воздействие на проект, внесение невстроенных тестов и проверка поведения системы вообще на её взаимодействие с программами

Объектом обсуждения этой главы является модульное тестирование по дисциплиине [xUnit](https://ru.wikipedia.org/wiki/xUnit), задающее собственный путь тестирования системы.

В рамках Unit-тестов определён **раннер** (test **runner**) — основная программа, запускающая тесты. Он отвечает за проверку подключаемости тестирующего кода , фильтрацию тестов, сбор информации по запускам и т.д. Все **тесты** (**test**) объединены в отдельные **тестовые комплекты** (test **case**), проверяющие какое-то конкретное свойство проекта. Множества блоков, описывающих один раздел работы с проектом объединены в **тестовые случаи** (test **suite**). Как правило, в один тестовый случай входят тесты, работающие в одинаковых или похожих условиях, а если условия существенно разные (например, бэкенд в виде файла и бэкенд в базе данных) — в отдельные.

	Для более точного понимания можно запомнить, что случай показывает, «в каких условиях сломалось?», комплект — «какая функциональность сломалась?", а сам тест — «что именно сломалось?»

Следующий важный блок любого тестирования — подготовка и ликвидация тестируемого окружения — test **fixture**, или _фикстуры_. Фикстуры могут создаваться для каждого из уровней тестирования и описывать все временно создаваемые данные и предварительно выполняемые действия для проверки работоспособности системы.

Одним из критериев качества тестирования является test **coverage** — **покрытие**, описывающее полноту тестирования программы. Самый простой показатель — процент строк исходного текста проекта, которые были выполнены в ходе тестирования. Более сложные показатели включают в себя проверку различных **execution path** — путей выполнения кода: например, если в одно и то же место программы можно попасть, предварительно пройдя и клаузу `if` условного оператора, и клаузу `else`, нужно иметь _два набора_ тестов соответствующего места.

Одна из классических подсистем тестирования проектов на Си — [Check](https://libcheck.github.io/check/). Работа с ней также автоматизирована в autotools, что позволяет встраивать её в проекты и проводить тестирование при сборке пакетов без дополнительных действий.

Добавим тестирование в проект. Для начала укажем зависимость на check, воспользовавшись тем, что соответствующие проверки пакет check добавляет в утилиту определения зависимостей [pkgconfig](https://en.wikipedia.org/wiki/pkg-config):

`@user`: `syscall-master/configure.ac`

```patch
@@ 11,6 11,9 @@ AC_CONFIG_HEADERS([config.h])
 # Checks for programs.
 AC_PROG_CC

+# Joint pkgconfig library/include check and variable definition.
+PKG_CHECK_MODULES([CHECK],[check])
+
 # Checks for libraries.

 # Checks for header files.
```

Поскольку check — это просто библиотека, тесты — это обычные функции на Си. Каждая тестирующая программа состоит из нескольких частей:
* сами тесты;
* заданияе тестового комплдекта, тестовых случаев, раннера и, возможно фикстур;
* регистрация: какие случаи принадлежат каким комплектам, какие тесты принадлежат каким случаям;
* запуск раннера;
* освобождение ресурсов.

**TODO** кусок исходников без пояснений. Это минимальный тест? А точно он минимальный, а не генерат checkmk? [Вот тут вроде поменьше](https://libcheck.github.io/check/doc/check_html/check_3.html#Creating-a-Suite)

```c
#include <stdio.h>
#include <assert.h>
#include <check.h>
#include "syscall.h"

START_TEST(parse_arg_incl) {
	assert(parse_arg != NULL);
}
END_TEST

START_TEST(lookup_incl) {
	assert(lookup != NULL);
}
END_TEST

int main(int argc, char *argv[]) {
	Suite *suite = suite_create("incl"); // создаём тестовый случай
	TCase *testcase = tcase_create("incl"); // создаём тестовый комплект
	SRunner *runner = srunner_create(suite); // для тестового случая делаем раннер
	int ret;

	suite_add_tcase(suite, testcase); // добавляем комплект в случай
	tcase_add_test(testcase, parse_arg_incl); // добавляем тесты в комплект
	tcase_add_test(testcase, lookup_incl);
	srunner_run_all(runner, CK_ENV); // запускаем все тестовые случаи
	ret = srunner_ntests_failed(runner); // собираем информацию о тестах
	srunner_free(runner);
	return ret != 0;
}
```


Однако большая часть тестового файла вполне может быть сгенерирована, для этого в пакет libcheck входит утилита **checkmk**. Поэтому тестовые файлы пишутся всё так же на Си, но общая часть задаётся директивами, похожими на Си-препроцессор, а в `Makefile.am` добавляется вызов checkmk.

`@user`: `syscall-master/tests/Makefile.am`

```make
TESTS = include upstream
check_PROGRAMS = include upstream

.ts.c:
       checkmk $< > $@

AM_CFLAGS = -I$(top_builddir)/src @CHECK_CFLAGS@
LDADD = $(top_builddir)/src/libsyscall.la @CHECK_LIBS@
```

Традиционно исходники для checmkd имеют расширение `.ts` (от **t**est **s**uite), поэтому многие текстовые редакторы пытаются включить подсветку синтаксиса TypeScript — она, конечно, плохо подходит.

В самих тестах используются специальные функции-макросы для проверки значений. Проверка включает в себя работу как с локальными переменными тестов, так и с глобальными значениями, как, например, указатели на функции библиотеки.

Воспроизведём пример выше с использованием макросов:

`@user`: `syscall-master/tests/include.ts`

```ts
#include <check.h>
#include "syscall.h"

#test include
       ck_assert_ptr_nonnull(parse_arg);
       ck_assert_ptr_nonnull(lookup);
```

В более существенном примере проверим работоспособность некоторых функций:
 + Тестовые случаи описывают функциональность программы из разных файлов библиотеки;
 + Тестовые комплекты проверяют функциональность конкретной функции
 + Тесты описывают ситуации с конкретными параметрами:
	 + Разные или одинаковые имена системных вызовов
	 + Бинарный поиск системного вызова в таблице
	 + Обработку аргумента системного вызова


**TODO** отсюда начинаются полотенца исходников практически без описания. Если они добавлены, значит, в них содержится что-то важное, и наверняка это важное требует пояснений на русском.

`@user`: `syscall-master/tests/upstream.ts`

```ts
#include <check.h>
#include "syscall.h"

int res;
unsigned long ulres;

#suite utility
#tcase scomp
#test diff_syscalls
       Syscall sys1 = {"write", 0};
       Syscall sys2 = {"read", 0};
       res = scomp(&sys1, &sys2);
       ck_assert_int_gt(res, 0);

#test same_syscalls
       Syscall sys1 = {"open", 0};
       Syscall sys2 = {"open", 0};
       res = scomp(&sys1, &sys2);
       ck_assert_int_eq(res, 0);

#tcase lookup
#test found
       char name[] = "write";
       res = lookup(name);
       ck_assert_int_eq(res, 1);

#suite basic
#tcase parse_arg
#test arg_length
       char syscall_name[] = "write";
       char arg[] = "#hello";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 5);

#test arg_retval
       ret_values[12] = 42;

       char syscall_name[] = "write";
       char arg[] = "$12";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 42);

#test arg_number
       char syscall_name[] = "write";
       char arg[] = "100500";
       ulres = parse_arg(syscall_name, arg);
       ck_assert_uint_eq(ulres, 100500);
```

В `spec`-файле к зависимости на генератор документации нужно также добавить зависимости на сам `check` и на его C-библиотеку:

`@user`: `syscall-master/.gear/syscall.spec`

```spec
Name: syscall
Version: 1.1
Release: alt1

Summary: send system calls from your shell
URL: https://github.com/oliwer/syscall
License: ISC
Group: Other

Source0: %name-%version.tar.gz

# Automatically added by buildreq on Fri Aug 08 2025
# optimized out: glibc-kernheaders-generic glibc-kernheaders-x86 gnu-config libgpg-error perl perl-Encode perl-Pod-Escapes perl-Pod-Simple perl-parent perl-podlators sh5
BuildRequires: perl-Pod-Usage libcheck-devel check

%description
Execute a list of raw system calls. All the system calls listed in your system's
unistd.h are supported, with up to 5 arguments. A maximum of 20 calls can be
executed per invocation, each separated by a comma.

Arguments starting by a # symbol are used to give a string length.
For instance, #hello would be evaluated as 5.

Arguments starting by a $ followed by a number from 0 to 19 refer to a previous
system call return code. For instance, $0 refers to to the return code of the
first system call executed.
To display those values, use the echo built-in command.

The echo command can be used like any other system call
to easily display $ or # values, or any string or number.

%prep
%setup

%build
%autoreconf
%configure
%make_build

%install
%makeinstall_std

%check
make check

%files
%_bindir/%name
%_libdir/*
%_man1dir/*

%changelog
* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.1-alt1
- Add xUnit check

* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.0-alt1
- Initial Build
```

```
.
├── configure.ac
├── doc
│   ├── Makefile.am
│   └── syscall.pod
├── LICENSE
├── Makefile.am
├── src
│   ├── basic.c
│   ├── globals.c
│   ├── lssyscalls
│   ├── Makefile.am
│   ├── syscall.c
│   ├── syscall.h
│   └── utility.c
└── tests
   ├── include.ts
   ├── Makefile.am
   └── upstream.ts
.gear/
├── rules
└── syscall.spec
```

`@user`
```console
[user@VM syscall-master]$ gear-hsh --lazy
<...>
Executing(%check): /bin/sh -e /usr/src/tmp/rpm-tmp.70349
+ umask 022
+ /bin/mkdir -p /usr/src/RPM/BUILD
+ cd /usr/src/RPM/BUILD
+ cd syscall-1.1
+ make check
<...>
checkmk include.ts > include.c
<...>
PASS: include
PASS: upstream
============================================================================
Testsuite summary for syscall 1.0
============================================================================
# TOTAL: 2
# PASS:  2
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
<...>
Wrote: /usr/src/RPM/SRPMS/syscall-1.1-alt1.src.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/syscall-1.1-alt1.x86_64.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/syscall-debuginfo-1.1-alt1.x86_64.rpm (w2.lzdio)
11.68user 11.20system 0:23.99elapsed 95%CPU (0avgtext+0avgdata 24184maxresident)k
760inputs+19696outputs (0major+888811minor)pagefaults 0swaps
[user@VM syscall-master]$

[user@VM syscall-master]$ cp ~/hasher/repo/x86_64/RPMS.hasher/syscall-1.1-alt1.x86_64.rpm ~/hasher/chroot/.in/
[user@VM syscall-master]$ hsh-shell --rooter
```

`@rooter`
```console
[root@localhost .in]# rpm -i syscall-1.1-alt1.x86_64.rpm
<13>Aug  8 11:55:52 rpm: syscall-1.1-alt1 1754653927 installed
[root@localhost .in]# which syscall
/usr/bin/syscall
[root@localhost .in]# ls /usr/share/man/man1/syscall.1.xz
/usr/share/man/man1/syscall.1.xz

[root@localhost .in]# cd
[root@localhost ~]# syscall open my.file е101 0755 , write '$0' hello '#hello' , close '$0'
[root@localhost ~]# cat my.file
hello[root@localhost ~]#
```

Теперь для версии 1.2 добавим параметр покрытия тестами программы. Для этого добавим в `configure.ac` дополнительный ключ для запуска утилиты [gcov](https://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html), которая и обеспечит результаты тестирования:

`@user`: `syscall-master/Makefile.am`

```make
SUBDIRS = src doc tests

checklog:       check
       cat tests/*.log

gcov:   check
       $(MAKE) -C src gcov
```

`@user`: `syscall-master/configure.ac`

```
#                                               -*- Autoconf -*-
# Process this file with autoconf to produce a configure script.


AC_INIT([syscall], [1.0], [UsamG1t])
AC_CONFIG_SRCDIR([src/syscall.c])
AM_INIT_AUTOMAKE([foreign subdir-objects])
LT_INIT([disable-static])
AC_CONFIG_HEADERS([config.h])

# Checks for programs.
AC_PROG_CC

# Joint pkgconfig library/include check and variable definition.
PKG_CHECK_MODULES([CHECK],[check])

# Variable definitins
AC_SUBST(CK_VERBOSITY, verbose)
AC_ARG_VAR(CK_VERBOSITY, [Default: "verbose", can be "silent", "minimal" or "normal")])

# Enabe/disable things
AC_ARG_ENABLE([gcov],
             [AS_HELP_STRING([--enable-gcov], [use Gcov to test the test suite])],
             [], [enable_gcov=no])

AM_CONDITIONAL([COND_GCOV],[test '!' "$enable_gcov" = no])# Checks for libraries.

# Checks for header files.
AC_CHECK_HEADERS([err.h])
AC_CHECK_HEADERS([errno.h])
AC_CHECK_HEADERS([limits.h])
AC_CHECK_HEADERS([stdio.h])
AC_CHECK_HEADERS([stdlib.h])
AC_CHECK_HEADERS([string.h])
AC_CHECK_HEADERS([unistd.h])

# Optional clues

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.
AC_FUNC_ERROR_AT_LINE

AC_CONFIG_FILES([Makefile src/Makefile doc/Makefile tests/Makefile])
AC_OUTPUT
```

`@user`: `syscall-master/src/Makefile.am`

```make
CFLAGS  = -Wall -O0 -g
if COND_GCOV
CFLAGS  += -fprofile-arcs -ftest-coverage
endif

lib_LTLIBRARIES=libsyscall.la
libsyscall_la_SOURCES=globals.c utility.c basic.c
BUILT_SOURCES = syscall.h systab.h

bin_PROGRAMS = syscall
syscall_SOURCES = syscall.c
syscall_LDADD = libsyscall.la

systab.h:
       sh lssyscalls | awk '{printf "{\"%s\", %d},\n", $$1, $$2}' > $@

gcov:
       gcov -o .libs libsyscall -t -k -b | grep -v -E '[[:digit:]]:[ /][*]'
```

`@user`: `syscall-master/.gear/syscall.spec`

```spec
%def_enable gcov

Name: syscall
Version: 1.2
Release: alt1

Summary: send system calls from your shell
URL: https://github.com/oliwer/syscall
License: ISC
Group: Other

Source0: %name-%version.tar.gz

# Automatically added by buildreq on Fri Aug 08 2025
# optimized out: glibc-kernheaders-generic glibc-kernheaders-x86 gnu-config libgpg-error perl perl-Encode perl-Pod-Escapes perl-Pod-Simple perl-parent perl-podlators sh5
BuildRequires: perl-Pod-Usage check libcheck-devel

%description
Execute a list of raw system calls. All the system calls listed in your system's
unistd.h are supported, with up to 5 arguments. A maximum of 20 calls can be
executed per invocation, each separated by a comma.

Arguments starting by a # symbol are used to give a string length.
For instance, #hello would be evaluated as 5.

Arguments starting by a $ followed by a number from 0 to 19 refer to a previous
system call return code. For instance, $0 refers to to the return code of the
first system call executed.
To display those values, use the echo built-in command.

The echo command can be used like any other system call
to easily display $ or # values, or any string or number.

%prep
%setup

%build
%autoreconf
%configure %{subst_enable gcov}
%make_build

%install
%makeinstall_std

%check
make check
make gcov

%files
%_bindir/%name
%_libdir/*
%_man1dir/*

%changelog
* Mon Aug 11 2025 UsamG1t <usamg1t@altlinux.org> 1.2-alt1
- Add gcov

* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.1-alt1
- Add xUnit check

* Fri Aug 08 2025 UsamG1t <usamg1t@altlinux.org> 1.0-alt1
- Initial Build
```

`@user`
```console
[user@VM syscall-master]$ gear-hsh --lazy
<...>
Executing(%check): /bin/sh -e /usr/src/tmp/rpm-tmp.73347
+ umask 022
+ /bin/mkdir -p /usr/src/RPM/BUILD
+ cd /usr/src/RPM/BUILD
+ cd syscall-1.2
+ make check
<...>
checkmk include.ts > include.c
<...>
PASS: include
PASS: upstream
============================================================================
Testsuite summary for syscall 1.0
============================================================================
# TOTAL: 2
# PASS:  2
# SKIP:  0
# XFAIL: 0
# FAIL:  0
# XPASS: 0
# ERROR: 0
============================================================================
<...>
make -C src gcov
make[1]: Entering directory '/usr/src/RPM/BUILD/syscall-1.2/src'
gcov -o .libs basic -t -k -b | grep -v -E '[[:digit:]]:[ /][*]'
       -:    0:Colorization: profile count: zero coverage (exceptional) zero coverage (unexceptional) unexecuted block
       -:    0:Source:basic.c
       -:    0:Graph:.libs/basic.gcno
       -:    0:Data:.libs/basic.gcda
       -:    0:Runs:14
       -:    1:#include "syscall.h"
       -:    2:
function parse_arg called 6 returned 100% blocks executed 81%
       6:    3:unsigned long parse_arg(const char *syscall_name, char *arg)
       -:    4:{
       -:    5:  unsigned long num;
       6:    6:  char *endp = NULL;
       -:    7:
       -:    8:  /* #hello - length of a string */
       6:    9:  if (arg[0] == '#') {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
       2:   10:    return (unsigned long)strlen(arg + 1);
       -:   11:  }
       -:   12:
       -:   13:  /* $0 - return value of a previous syscall */
       4:   14:  if (arg[0] == '$') {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
       2:   15:    num = strtoul(arg + 1, &endp, 10);
call    0 returned 100%
       2:   16:    if (num < CMD_MAX - 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       2:   17:      return (unsigned long)ret_values[num];
       -:   18:    }
       -:   19:  }
       -:   20:
       -:   21:  /* Try to parse it as a number */
       2:   22:  endp = NULL;
       2:   23:  num = strtoul(arg, &endp, 0);
call    0 returned 100%
       2:   24:  if (errno == ERANGE) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       0:   25:    errx(1, "%s: argument '%s' is out of range",
call    0 never executed
       -:   26:      syscall_name, arg);
       -:   27:  }
       2:   28:  if (endp && *endp == '\0') {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
       -:   29:    /* strtoul succeeded */
       2:   30:    return num;
       -:   31:  }
       -:   32:
       -:   33:  /* assume it is a string */
       -:   34:  /* unescape any \n at the end of the string */
       0:   35:  unescape_nl(arg);
call    0 never executed
       0:   36:  return (unsigned long)arg;
       -:   37:}
       -:   38:
<...>
```
