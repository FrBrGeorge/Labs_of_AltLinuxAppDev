Данная лабораторная работа продолжает повествование главы о [регулярных выражениях](https://github.com/UsamG1t/Methodics_of_LinuxAppDev/blob/master/Methodical_manual/05_Regexps/5.%20%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5%20%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F.md).

---

При работе с текстовыми данными одной из важных задач является сопоставление шаблону. Поиск шаблонов встречается постоянно для уточнения и выделения интересующих нас данных. На основании полученных данных можно принимать решение по фильтрации или редактированию материала. 

Одним из примитивных языков шаблонов выступает представленный в `Shell` вариант. Также этот язык шаблонов оформлен в качестве отдельной утилиты [glob](https://man7.org/linux/man-pages/man7/glob.7.html). Он используется преимущественно для проверок соответствия пути файлов.

Основным языком шаблонов в большинстве задач поиска выступает [язык регулярных выражений](https://dl.ebooksworld.ir/motoman/OReilly.Mastering.Regular.Expressions.3rd.Edition.www.EBooksWorld.ir.pdf). Он позволяет описывать более сложные в сравнении с предыдущим языком конструкции, однако всё ещё **не является полным** и, кроме этого, очень перегружает общий вид шаблона.

Классическими утилитами, использующими регулярные выражения, являются утилита поиска по шаблону [`grep`](https://man7.org/linux/man-pages/man1/grep.1.html) и потоковый редактор [`sed`](https://man7.org/linux/man-pages/man1/sed.1.html). Они поддерживают работу как с класическими регулярными выражениями, так и с [расширенными](https://man7.org/linux/man-pages/man7/regex.7.html). 

При разработке используются библиотеки, предназначенные для работы с регулярными выражениями. В стандартной библиотеке языка Си есть встроенная [обработка регулярных выражений](https://man7.org/linux/man-pages/man3/regcomp.3.html). Кроме регулярных выражений также используют, так называемые, "нерегулярные" выражения. К ним относятся [`PCRE`](http://man7.org/linux/man-pages/man3/pcre.3.html) или, например, [регулярные выражения `Python`](https://docs.python.org/3/library/re).

## Пример использования регулярных выражений в Си

Соберём пакет, программы в котором будут выполнять роль утилиты `grep`. Для сборки воспользуемся [`gear`](https://docs.altlinux.org/ru-RU/alt-platform/10.1/html-single/alt-platform/index.html#gear--chapter), где соберём пакет с нуля.

`@user`
```console
[papillon_jaune@usamg1tVM ~]$ mkdir regex-pkg  
[papillon_jaune@usamg1tVM ~]$ cd regex-pkg/  
[papillon_jaune@usamg1tVM regex-pkg]$ git init  
<...>
Initialized empty Git repository in /home/papillon_jaune/regex-pkg/.git/  
[papillon_jaune@usamg1tVM regex-pkg]$
```

`@user`: `regex-pkg/regex-no-bags.c`

```c
#include <stdio.h>  
#include <stdlib.h>  
#include <regex.h>  
  
int main(int argc, char** argv) {  
       char *text;  
       size_t size = 0;  
       int len;  
       regex_t regex;  
  
       regcomp(&regex, argv[1], REG_EXTENDED);  
  
       for (text = NULL; (len = getline(&text, &size, stdin)) != -1; free(text), text = NULL) {  
               text[len - 1] = 0;  
               if (regexec(&regex, text, 0, NULL, 0) == 0)  
                       puts(text);  
       }  
  
       regfree(&regex);  
       return 0;  
}
```

Подробнее обсудим ключевые функции для работыс регулярными выражениями:
 + `regcomp` на основе полученного шаблона строит структуру регулярного выражения для поиска подходящих шаблонов. Флаг `REG_EXTENDED` указывает на использование расширенных РВ;
 + `regexec` находит в указанной строке шаблон регулярного выражения по принципу "Самый левый, самый длинный";
 + `regfree` освобождает структуру, выделенную вдинамической памяти.

`@user`: `regex-pkg/regex-bags.c`

```c
#include <stdio.h>  
#include <stdlib.h>  
#include <regex.h>  
  
#define MAXGR 10  
  
int main(int argc, char** argv) {  
       char *text;  
       size_t size = 0;  
       int len;  
       regex_t regex;  
       regmatch_t bags[MAXGR];  
  
  
       regcomp(&regex, argv[1], REG_EXTENDED);  
  
       for (text = NULL; (len = getline(&text, &size, stdin)) != -1; free(text), text = NULL) {  
               text[len - 1] = '\0';  
               if (regexec(&regex, text, MAXGR, bags, 0) == 0) {  
                       puts(text);  
                       for(int i = 1; i < MAXGR && bags[i].rm_so >= 0; i++) {  
                               int begin = bags[i].rm_so;  
                               int end = bags[i].rm_eo;  
                               printf("Bag %d: position %d - %d\t%.*s\n",    
                                               i, begin, end, end - begin, text + begin);  
                       }  
               }  
       }  
       regfree(&regex);  
       return 0;  
}
```

 + Дополнительные параметры в `regexec` позволяют не только найти подходящую под шаблон подстроку, но и разбить её на "карманы" соответственно структуре РВ;
 + Каждый карман описывается двумя параметрами: индексами начала и конца кармана в исходной строке.

