Данная лабораторная работа продолжает повествование первой части главы о [библиотеках и тестировании](https://github.com/UsamG1t/Methodics_of_LinuxAppDev/blob/master/Methodical_manual/10_LibTesting/10.%20%D0%91%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8%20%D0%B8%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.md).

---

При работе с проектами частой задачей становится создание и подключение библиотек. В библиотеки обычно выносится логика, общая для нескольких создаваемых исполняемых файлов, или публичное API, позволяющее использовать функции проекта в других разработках. Использование библиотек делает процесс сборки многоступенчатым: сначала надо скомпилировать исходники, затем из некоторых объектных файлов собрать библиотеку, а только затем — готовую программу. Если библиотека разделяемая, для запуска программы, которая её использует, необходимо вручную указывать место её расположения через `LD_PRELOAD` и `LD_LIBRARY_PATH`. Для удобной работы с библиотеками и их тестирования необходимо использовать специальные инструменты по автосборке. Классическим инструментом сборки библиотек является [GNU Libtool](https://www.gnu.org/software/libtool/manual/libtool.html).

## Использование Libtool вручную

Рассмотрим простую программу, которая прибавляет константу к числу, разобьём её на основной код, файл с основной функцией, файл с глобальной переменной-константой и заголовочный файл:

`@user`: `inc-pkg/main.c`

```c
#include <stdio.h>
#include <stdlib.h>
#include "libinc.h"

int main(int argc, char *argv[]) {
        int n;

        if(argc < 2) {
          fprintf(stderr, "Usage: %s NUMBER\n", argv[0]);
          return 1;
        }

        n = atoi(argv[1]);
        printf("%d\n", inc(n));

 return 0;
}
```

`@user`: `inc-pkg/fun.c`

```c
#include "libinc.h"

int inc(int var) {
  return var + inc_var;
}
```

`@user`: `inc-pkg/global.c`

```c
#include "libinc.h"
int inc_var = 1;
```

`@user`: `inc-pkg/libinc.h`

```c
int inc(int);
extern int inc_var;
```

Опишем `Makefile` с использованием Libtool и рассмотрим подробнее используемые команды:

`@user`: `inc-pkg/Makefile`

```make
CFLAGS = -g -O
LTFLAGS = --tag=CC

all:    inc

%.lo:   %.c
       libtool --mode=compile $(LTFLAGS) $(CC) -c $<
libinc.la: fun.lo global.lo
       libtool --mode=link $(LTFLAGS) $(CC) -o $@ $^ -rpath /usr/lib64
inc:    main.o libinc.la
       libtool --mode=link $(LTFLAGS) $(CC) -o $@ $^
check:  inc
       test "`./$< 123`" = "124"
clean:
       rm -rf *.so inc .libs *.l? *.o
```

 + Утилита `libtool` управляет и компиляцией, и компоновкой (определяется флагом `--mode=`), и ей необходимо передавать дополнительные параметры (например, информацию о компиляторе), такие параметры мы храним в переменной `LTFLAGS`. При этом базовые флаги компиляции и компоновки (например, `-fPIC` для разделяемых библиотек) добавляются автоматически.
 + В результате компиляции порождаются `.lo`-файлы (так называемые «libtool objects»). Libtool object — это shell-сценарий с мета-информацией о том, где лежат «настоящие» объектные файлы (причём как собранные с флагом `-fPIC` для динамической компоновки, так и без него для статической).
 + На основе `.lo`-файлов создаётся «libtool archive» (`.la`). Это тоже shell-сценарии с мета-информацией о собранных вариантах библиотек (статическом и динамическом).
 + Исполняемый файл, который порождается `libtool` — это, конечно, тоже shell-сценарий, в котором вся информация перерабатывается, выбирается тип сборки, при необходимости указывается место расположения «настоящей» динамической библиотеки, после чего вызывается соответствующая программа. Таким образом, результат работы `libtool` можно запускать сразу, минуя все эти стадии.
 + Простейшие примеры запуска `libtool` для получения `.lo`, `.la` и исполняемых файлов приведены выше.

Соберём проект и рассмотрим ближе некоторые файлы:

`@user`
```console
[user@VM inc-pkg]$ make
cc -g -O   -c -o main.o main.c
libtool --mode=compile --tag=CC cc -c fun.c
libtool-default: compile:  cc -c fun.c  -fPIC -DPIC -o .libs/fun.o
libtool-default: compile:  cc -c fun.c -o fun.o >/dev/null 2>&1
libtool --mode=compile --tag=CC cc -c global.c
libtool-default: compile:  cc -c global.c  -fPIC -DPIC -o .libs/global.o
libtool-default: compile:  cc -c global.c -o global.o >/dev/null 2>&1
libtool --mode=link --tag=CC cc -o libinc.la fun.lo global.lo -rpath /usr/lib64
libtool-default: link: x86_64-alt-linux-gcc -shared  -fPIC -DPIC  .libs/fun.o .libs/global.o      -Wl,-soname -Wl,libinc.so.0 -o .libs/libinc.so.0.0.0
libtool-default: link: (cd ".libs" && rm -f "libinc.so.0" && ln -s "libinc.so.0.0.0" "libinc.so.0")
libtool-default: link: (cd ".libs" && rm -f "libinc.so" && ln -s "libinc.so.0.0.0" "libinc.so")
libtool-default: link: ar cr .libs/libinc.a  fun.o global.o
libtool-default: link: ranlib .libs/libinc.a
libtool-default: link: ( cd ".libs" && rm -f "libinc.la" && ln -s "../libinc.la" "libinc.la" )
libtool --mode=link --tag=CC cc -o inc main.o libinc.la
libtool-default: link: cc -o .libs/inc main.o  ./.libs/libinc.so
[user@VM inc-pkg]$
```

```
.
├── fun.c
├── fun.lo
├── fun.o
├── global.c
├── global.lo
├── global.o
├── inc
├── libinc.h
├── libinc.la
├── main.c
├── main.o
└── Makefile
.libs/
├── fun.o
├── global.o
├── inc
├── libinc.a
├── libinc.la -> ../libinc.la
├── libinc.lai
├── libinc.so -> libinc.so.0.0.0
├── libinc.so.0 -> libinc.so.0.0.0
└── libinc.so.0.0.0
```

Во-первых, среди получившихся файлов появились два файла `inc`. Находящийся в `.libs/` — непосредственно исполняемый файл. Находящийся в текущем каталоге — на самом деле shell-сценарий, в котором автоматически прописываются пути к динамическим библиотекам, и программа вызывается с их неявным указыванием.

`@user`
```console
[user@VM inc-pkg]$ diff inc .libs/inc
Двоичные файлы inc и .libs/inc различаются
[user@VM inc-pkg]$ head -n1 inc
#! /bin/sh
[user@VM inc-pkg]$ grep "LD_LIBRARY_PATH" inc
relink_command="(cd /home/user/inc-pkg; { test -z \"\${LIBRARY_PATH+set}\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \"\${COMPILER_PATH+set}\" || unset COMPILER_PA
TH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \"\${GCC_EXEC_PREFIX+set}\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \"\${LD_RUN_PATH+set}\" || unset
LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \"\${LD_LIBRARY_PATH+set}\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=/home/user/.gemie/bin
:/home/user/bin:/usr/bin:/bin:/usr/local/bin:/usr/games; export PATH; cc -o \$progdir/\$file main.o  ./.libs/libinc.so -Wl,-rpath -Wl,/home/user/inc-pkg/.libs)"
[user@VM inc-pkg]$
[user@VM inc-pkg]$ ./inc 123
124
[user@VM inc-pkg]$ .libs/inc 123
.libs/inc: error while loading shared libraries: libinc.so.0: cannot open shared object file: No such file or directory
[user@VM inc-pkg]$ LD_LIBRARY_PATH=`pwd`/.libs .libs/inc 123
124
[user@VM inc-pkg]$
```

`.la`- и `.lo`-файлы также не являются объектными, а лишь описывают параметры итоговой библиотеки для сборки:

`@user`
```console
[user@VM inc-pkg]$ cat libinc.la
# libinc.la - a libtool library file
# Generated by libtool (GNU libtool) 2.4.7
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# The name that we can dlopen(3).
dlname='libinc.so.0'

# Names of this library.
library_names='libinc.so.0.0.0 libinc.so.0 libinc.so'

# The name of the static archive.
old_library='libinc.a'

# Linker flags that cannot go in dependency_libs.
inherited_linker_flags=''

# Libraries that this one depends upon.
dependency_libs=''

# Names of additional weak libraries provided by this library
weak_library_names=''

# Version information for libinc.
current=0
age=0
revision=0

# Is this an already installed library?
installed=no

# Should we warn about portability when linking against -modules?
shouldnotlink=no

# Files to dlopen/dlpreopen
dlopen=''
dlpreopen=''

# Directory that this library needs to be installed in:
libdir='/usr/lib64'
[user@VM inc-pkg]$ cat *.lo
# fun.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.7
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/fun.o'

# Name of the non-PIC object
non_pic_object='fun.o'

# global.lo - a libtool object file
# Generated by libtool (GNU libtool) 2.4.7
#
# Please DO NOT delete this file!
# It is necessary for linking the library.

# Name of the PIC object.
pic_object='.libs/global.o'

# Name of the non-PIC object
non_pic_object='global.o'

[user@VM inc-pkg]$
```

## Версионирование

Подробнее рассмотрим получившуюся библиотеку для обсуждения версионирования:

`@user`
```console
[user@VM inc-pkg]$ ls -la .libs/*.so*
lrwxrwxrwx 1 user user    15 авг  4 16:08 .libs/libinc.so -> libinc.so.0.0.0
lrwxrwxrwx 1 user user    15 авг  4 16:08 .libs/libinc.so.0 -> libinc.so.0.0.0
-rwxr-xr-x 1 user user 15416 авг  4 16:08 .libs/libinc.so.0.0.0
[user@VM inc-pkg]$
```

При работе с библиотеками (и, в целом, любыми объектами, требующими явный параметр для отслеживания изменений и совместимости) принято использовать специальные правила [версионирования](https://www.gnu.org/software/libtool/manual/libtool.html#Versioning).

Во-первых, это формат хранения библиотек в виде одного файла с сопутствующими символьными ссылками. Бесчисловая версия используется для создания зависимостей на библиотеку при сборке (если не требуется строгая зависимость на конкретную версию), мажорная («основная», с одним числом) используется для указания на основную поддерживаемую версию, а последняя (единственная реальная библиотека) является самим рабочим объектом.

Во-вторых, это параметры, по которым ведётся отслеживание изменений, и правила версионирования. В случае с библиотеками версионирование описывается через изменение **ABI** — [Application Binary Interface](https://ru.wikipedia.org/wiki%3A%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9). Если [API](https://ru.wikipedia.org/wiki%3AAPI) описывает, с какими параметрами следует вызывать функции библиотеки в _исходных текстах_ программ, и какие значения они возвращают, то ABI отражает, во что именно эта договорённость превращается _после компиляции_. Таким образом, очень важно, чтобы исполняемый файл и разделяемая библиотека были _совместимы по ABI_: если такая совместимость есть, пускай даже при сборке программы использовалась библиотека слегка другой версии, программа будет работать штатно. Если совместимости нет, то _лучшее_, что может сделать библиотека — это немедленно завершить программу с ошибкой.

Повсеместно используемые большие библиотеки, например, [GLibc](https://ru.wikipedia.org/wiki%3Aglibc), могут быть совместимы сразу с несколькими `ABI`, для более простых случаев Libtool предлагает схему из трёх счётчиков — [current:revision:age](https://www.gnu.org/software/libtool/manual/html_node/Libtool-versioning.html):
 + `current` увеличивается при каждом изменении ABI — это т. н. «номер интерфейса»;
 + `revision` увеличивается при каждом изменении в библиотеке, которое не отразилось на ABI (исправление ошибок, изменение функциональности и т. п.); если `current` увеличилось, `revision` обнуляется;
 + `age` изменяется вместе с `current`; он увеличивается при каждом _обратно совместимом_ изменении (например, при добавлении новой функции или при изменении, не затрагивающем ABI), а в противном случае — обнуляется.

Таким образом, Libtool versioning решает сразу три задачи:
1. При _любом_ изменении версия увеличивается;
2. При изменении ABI версия увеличивается настолько, что становится больше любых версий, в которых ABI не поменялось;
3. По версии можно узнать _диапазон_ предоставляемых «номеров интерфейса», с которыми гарантирована обратная совместимость — это диапазон от `current` до `current - age`.

При более простом _семантическом_ версионировании описание ведётся значениями `MAJOR.MINOR.PATCH` и меняется по следующим правилам:
 + Обратно **не**совместимые изменения ABI (удаление / изменение)— `MAJOR++.MINOR=0.PATCH=0`
 + Обратно совместимые изменения ABI (добавление) — `MAJOR.MINOR++.PATCH=0`
 + Обратно совместимые исправления ABI и изменения, не затрагивающие ABI — `MAJOR.MINOR.PATCH++`


## Автоматизация Libtool

Поскольку Libtool является классическим инструментом автосборки библиотек, в Autotools есть поддержка его обработки.

Для начала соберём классический `configure.ac`

`@user`: `inc-pkg/configure.ac`

```sh
AC_INIT([inc], [1.0], [UsamG1t])
AC_CONFIG_SRCDIR([src/main.c])
AM_INIT_AUTOMAKE([foreign subdir-objects])
AC_CONFIG_HEADERS([config.h])

# Checks for programs.
AC_PROG_CC

# Checks for libraries.

# Checks for header files.
AC_CHECK_HEADERS([stdlib.h])

# Optional clues

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.
AC_FUNC_ERROR_AT_LINE

AC_CONFIG_FILES([Makefile src/Makefile])
AC_OUTPUT
```

Перенесём исходники в отдельную поддиректорию и сделаем `Makefile.am` для обработки:

```
.
├── configure.ac
├── Makefile.am
└── src
   ├── fun.c
   ├── global.c
   ├── libinc.h
   ├── main.c
   └── Makefile.am
```

`@user`: `inc-pkg/Makefile.am`

```make
SUBDIRS = src
```

`@user`: `inc-pkg/src/Makefile.am`

```make
CFLAGS  = -Wall -O0 -g

bin_PROGRAMS = inc
inc_SOURCES = main.c fun.c global.c

fun.c global.c: libinc.h

check:  inc
       test "`./$< 123`" = "124"
```

Сборка уже работает корректно, однако получился просто многофайловый проект. Добавим обработку Libtool: в `configure.ac` добавим инициализацию Libtool и укажем явный запрет сборки статической библиотеки, в `src/Makefile.am` укажем сборку библиотеки из исходников (`lib_LTLIBRARIES`), а также связь библиотеки с исполняемым файлом (`inc_LDADD`).

`@user`: `inc-pkg/configure.ac`

```sh
AC_INIT([inc], [1.0], [UsamG1t])
AC_CONFIG_SRCDIR([src/main.c])
AM_INIT_AUTOMAKE([foreign subdir-objects])
LT_INIT([disable-static])
AC_CONFIG_HEADERS([config.h])

# Checks for programs.
AC_PROG_CC

# Checks for libraries.

# Checks for header files.
AC_CHECK_HEADERS([stdlib.h])

# Optional clues

# Checks for typedefs, structures, and compiler characteristics.

# Checks for library functions.
AC_FUNC_ERROR_AT_LINE

AC_CONFIG_FILES([Makefile src/Makefile])
AC_OUTPUT
```

`@user`: `inc-pkg/src/Makefile.am`

```make
CFLAGS = -Wall -O0 -g

lib_LTLIBRARIES = libinc.la
libinc_la_SOURCES = fun.c global.c

bin_PROGRAMS = inc
inc_SOURCES = main.c
inc_LDADD = libinc.la

BUILT_SOURCES = libinc.h

check: inc
        test "`./$< 123`" = "124"
```

Добавим `.gear/rules` и spec-файл для сборки пакета.

`@user`: `inc-pkg/.gear/rules`

```sh
spec:   .gear/inc.spec
tar.gz: . name=@name@-@version@
```

`@user`: `inc-pkg/.gear/inc.spec

```spec
Name: inc
Version: 1.0
Release: alt1

Summary: Test pkg with libtool

License: GPL-3.0-or-later
Group: Development/Other

Source0: %name-%version.tar.gz

%description
This is a small testing package, builded with libtool

%prep
%setup

%build
%autoreconf
%configure
%make_build

%install
%makeinstall_std

%check
make check

%files
%_bindir/%name
%_libdir/*

%changelog
* Tue Aug 05 2025 UsamG1t <usamg1t@altlinux.org> 1.0-alt1
- Initial Build
```

Напомним, что в Autotools задаются места для установки всех компонентов проекта, а в макросе `%configure` они определены в соответствии с дисциплиной оформления пакетов ALT. Библиотека `libinc.so` автоматически установится в `/usr/lib64`, и при описании файлов пакета (директива `%files`) необходимо будет просто указать директорию `%_libdir`.

```
.
├── configure.ac
├── Makefile.am
└── src
   ├── fun.c
   ├── global.c
   ├── libinc.h
   ├── main.c
   └── Makefile.am
.gear/
├── inc.spec
└── rules
```

`@user`
```console
[user@VM inc-pkg]$ gear-hsh --lazy
<...>
Executing(%build): /bin/sh -e /usr/src/tmp/rpm-tmp.60211
<...>
+ make -j2
<...>
/bin/sh ../libtool  --tag=CC   --mode=compile x86_64-alt-linux-gcc -DHAVE_CONFIG_H -I. -I..     -Wall -O0 -g -c -o fun.lo fun.c
libtool: compile:  x86_64-alt-linux-gcc -DHAVE_CONFIG_H -I. -I.. -Wall -O0 -g -c fun.c  -fPIC -DPIC -o .libs/fun.o
/bin/sh ../libtool  --tag=CC   --mode=compile x86_64-alt-linux-gcc -DHAVE_CONFIG_H -I. -I..     -Wall -O0 -g -c -o global.lo global.c
libtool: compile:  x86_64-alt-linux-gcc -DHAVE_CONFIG_H -I. -I.. -Wall -O0 -g -c global.c  -fPIC -DPIC -o .libs/global.o
/bin/sh ../libtool  --tag=CC   --mode=link x86_64-alt-linux-gcc  -Wall -O0 -g   -o libinc.la -rpath /usr/lib64 fun.lo global.lo
libtool: link: x86_64-alt-linux-gcc -shared  -fPIC -DPIC  .libs/fun.o .libs/global.o    -O0 -g   -Wl,-soname -Wl,libinc.so.0 -o .libs/libinc.so.0.0.0
libtool: link: (cd ".libs" && rm -f "libinc.so.0" && ln -s "libinc.so.0.0.0" "libinc.so.0")
libtool: link: (cd ".libs" && rm -f "libinc.so" && ln -s "libinc.so.0.0.0" "libinc.so")
libtool: link: ( cd ".libs" && rm -f "libinc.la" && ln -s "../libinc.la" "libinc.la" )
/bin/sh ../libtool  --tag=CC   --mode=link x86_64-alt-linux-gcc  -Wall -O0 -g   -o inc main.o libinc.la
libtool: link: x86_64-alt-linux-gcc -Wall -O0 -g -o .libs/inc main.o  ./.libs/libinc.so
<...>
```

```console
Executing(%install): /bin/sh -e /usr/src/tmp/rpm-tmp.31330
<...>
make[3]: Entering directory '/usr/src/RPM/BUILD/inc-1.0/src'
/usr/bin/mkdir -p '/usr/src/tmp/inc-buildroot/usr/lib64'
/bin/sh ../libtool   --mode=install /usr/libexec/rpm-build/install -p   libinc.la '/usr/src/tmp/inc-buildroot/usr/lib64'
libtool: install: /usr/libexec/rpm-build/install -p .libs/libinc.so.0.0.0 /usr/src/tmp/inc-buildroot/usr/lib64/libinc.so.0.0.0
libtool: install: (cd /usr/src/tmp/inc-buildroot/usr/lib64 && { ln -s -f libinc.so.0.0.0 libinc.so.0 || { rm -f libinc.so.0 && ln -s libinc.so.0.0.0 libinc.so.0; }; })
libtool: install: (cd /usr/src/tmp/inc-buildroot/usr/lib64 && { ln -s -f libinc.so.0.0.0 libinc.so || { rm -f libinc.so && ln -s libinc.so.0.0.0 libinc.so; }; })
libtool: install: /usr/libexec/rpm-build/install -p .libs/libinc.lai /usr/src/tmp/inc-buildroot/usr/lib64/libinc.la
libtool: warning: remember to run 'libtool --finish /usr/lib64'
/usr/bin/mkdir -p '/usr/src/tmp/inc-buildroot/usr/bin'
 /bin/sh ../libtool   --mode=install /usr/libexec/rpm-build/install -p inc '/usr/src/tmp/inc-buildroot/usr/bin'
libtool: warning: 'libinc.la' has not been installed in '/usr/lib64'
libtool: install: /usr/libexec/rpm-build/install -p .libs/inc /usr/src/tmp/inc-buildroot/usr/bin/inc
<...>
Adjusting library links in /usr/src/tmp/inc-buildroot
./usr/lib64: (from <cmdline>:0)
       libinc.so.0 -> libinc.so.0.0.0
Verifying ELF objects in /usr/src/tmp/inc-buildroot (arch=normal,fhs=normal,lfs=relaxed,lint=relaxed,rpath=normal,stack=normal,textrel=normal,unresolved=normal)
Splitting links to aliased files under /{,s}bin in /usr/src/tmp/inc-buildroot
```

```console
Executing(%check): /bin/sh -e /usr/src/tmp/rpm-tmp.55059
<...>
test "`./inc 123`" = "124"
<...>
Wrote: /usr/src/RPM/SRPMS/inc-1.0-alt1.src.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/inc-1.0-alt1.x86_64.rpm (w2.lzdio)
Wrote: /usr/src/RPM/RPMS/x86_64/inc-debuginfo-1.0-alt1.x86_64.rpm (w2.lzdio)
7.09user 5.34system 0:15.58elapsed 79%CPU (0avgtext+0avgdata 22740maxresident)k
0inputs+17184outputs (0major+731782minor)pagefaults 0swaps
```

`@user`
```console
[user@VM inc-pkg]$ cp ~/hasher/repo/x86_64/RPMS.hasher/inc-1.0-alt1.x86_64.rpm ~/hasher/chroot/.in/
[user@VM inc-pkg]$ hsh-shell --rooter
```

`@rooter`
```console
[root@localhost .in]# rpm -i inc-1.0-alt1.x86_64.rpm
<13>Aug  5 12:39:54 rpm: inc-1.0-alt1 1754397543 installed
[root@localhost .in]# which inc
/usr/bin/inc
[root@localhost .in]# inc 123
124
[root@localhost .in]# ls -la /usr/lib64/libinc*
lrwxrwxrwx 1 root root    15 Aug  5 12:37 /usr/lib64/libinc.so -> libinc.so.0.0.0
lrwxrwxrwx 1 root root    15 Aug  5 12:37 /usr/lib64/libinc.so.0 -> libinc.so.0.0.0
-rw-r--r-- 1 root root 14232 Aug  5 12:37 /usr/lib64/libinc.so.0.0.0
[root@localhost .in]#
```

Стоит отдельно заметить, что _установка_ `.la`- и `.lo`-файлов в систему запрещена дисциплиной оформления пакетов `ALT Linux Team` (в том числе и из-за соображений безопасности). Библиотеки и использующие их приложения должны быть скомпилированы так, чтобы работать без дополнительной прослойки, требующей запуска Shell. Случайно установленные в `%buildroot` файлы таких типов просто удаляются на этапе формирования пакета.
